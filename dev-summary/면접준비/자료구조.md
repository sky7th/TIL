#### 자료구조의 선택 기준
- 처리시간, 양
- 프로그램의 유지보수
- 자료의 업데이트나 활용 정도
- 프로그래밍 기법의 용이성

#### 적절한 자료구조를 선택해야 하는 이유는?
- 큰 시스템을 제작할 때 구현의 난이도나 최종 결과물의 성능이 자료구조에 크게 의존하기 때문이다. 그래서 가장 우선적으로 고려되어야 한다.
- 그리고 일단 자료구조가 선택되면 적용할 알고리즘은 상대적으로 명확해진다.

## List, Set, Map
#### List, Set, Map 차이
- List: 순서가 있는 데이터의 집합. 데이터의 중복을 허용
- Set: 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않음
- Map: 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용

#### List, Set, Map는 어떤 인터페이스를 구현하나?
- List: List -> Collection -> Iterable
- Set: Set -> Collection -> Iterable
- Map: Map

#### foreach를 사용할 수 있는 자료구조는 어떤 인터페이스를 상속받고 있나요?
- Iterable

#### foreach는 다음 데이터를 얻기 위해서 내부적으로 호출되는 메서드가 있는데 뭘까요?
- hasNext() 로 다음 데이터가 있는지 확인하고 next()로 다음 엘리먼트를 리턴한다.

#### Iterator와 Iterable의 차이는 무엇인가요?
- Iterator 인터페이스는 다른 객체, 다른 종류의 컬렉션을 순회하게 해줄수 있다. 이 인터페이스를 순회하기 위해서는 hasNext() + next() 메소드를 사용해야한다.
- Iterable은 순회할 수 있는 컬렉션을 나타낸다. 이 인터페이스를 상속하게 되면 객체는 for-each loop를 사용할 수 있게 해준다.

#### Iterator에서 구현해야 하는 메서드들은 어떤 것이 있을까요?
- hasNext(), next()

#### 배열은 사이즈가 변경될 수 있나요?
- 아니요

#### 사이즈가 10인 배열에 20만큼을 넣거나 사이즈를 5로 줄이려면 어떻게?
- 기존 배열에 있던 데이터를 복사한 새로운 배열을 생성합니다.

#### size가 변경될 경우에는 어떤 자료구조를 사용하는게 좋을지?
- LinkedList

#### 제네릭 타입의 자료구조 장점은? 그냥 Object형을 저장하면 안되나요?
- 컴파일할 때 타입을 체크해서 에러를 사전에 잡을 수 있다.
- 컴파일러가 타입캐스팅을 해주기 때문에 편리하다. (Object형을 저장하면 반환할 때 타입캐스팅을 해줘야 함)
- 타입만 다르고 코드의 내용이 대부분 일치할 때 코드의 재사용성이 좋아진다.

## ArrayList, LinkedList
#### ArrayList, LinkedList 차이
- ArrayList는 인덱스 기반의 자료 구조라서 검색이 빠르지만 LinkedList는 검색 시 모든 요소를 탐색해야 하기 때문에 성능이 좋지 않다.
- ArrayList는 삽입, 삭제 이후 다른 데이터를 복사해야 한다. LinkedList는 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되는 ArrayList 보다 성능이 좋다.

#### ArrayList, LinkedList 
- 검색할 때 빠른 건 무엇인지: ArrayList
- 데이터 빈번하게 추가할 때 무엇을 써야하는지: LinkedList
- 삭제할 때 빠른 건 무엇인지: LinkedList

#### ArrayList, LinkedList 중간에 데이터 삭제할 떄 내부적 동작 과정
- ArrayList
  - 삽입: List의 크기를 삽입될 자료만큼 늘림 -> 삽입될 자료의 위치를 기준으로 기존의 데이터들을 뒤로 혹은 앞으로 이동 -> 해당 위치에 자료를 입력
  - 삭제: 삭제될 자료가 위치한 인덱스의 자료를 삭제 -> 삭제한 자료의 인덱스를 기준으로 이후의 자료들을 이동 -> List의 맨 마지막은 비어있는 상태로 삭제를 완료
- LinkedList
  - 삽입: 삽입할 위치 앞 뒤에 있는 노드들이 가리키는 노드 주소값을 바꿈
  - 삭제: 삭제할 노드의 이전 노드와 이후 노드를 연결

#### List에서 가장 검색이 느린 케이스


#### LinkedList는 이전 노드, 이후 노드의 정보를 어떻게 알까?
- 노드 안에 이전 노드와 이후 노드의 주소를 저장하고 있다.

## Set
#### List, Set 차이
- List는 중복을 허용하고, Set은 허용하지 않는다.

#### 중복을 허용하지 않는다면 내부적으로 동일하다는 것을 어떻게 확인?
- Set은 내부적으로 해쉬맵을 쓰고 있다. HashMap은 key의 hashCode가 같으면 덮어쓰기 때문에 이런 방법으로 중복을 제거한다.

#### 같다를 판단하는 기준을 바꿀수도 있나요?
- equals 메서드와 hashCode 메서드를 재정의하면 된다.

## Map
#### Map은 다른 자료구조와 뭐가 다른지
- Map은 대응관계를 쉽게 표현할 수 있게 해 주는 자료형

#### Map을 사용해야 하는 경우
- 빠른 검색을 필요로 할 때

#### 알고 있는 Map
- HashMap, HashTable, TreeMap, LinkedHashMap

#### HashTable과 HashMap은 뭐가 다른지
- HashMap은 null 값을 키와 값으로 허용하지만 HashTable은 null을 허용하지 않는다.
- 동기화가 필요없다면 HashMap을, 동기화 보장이 필요하다면 HashTable 사용한다.

#### HashTable, HashMap 내부 어떻게 구현이 되어있고 어떤 연산을 하는지
- HashMap의 내부구조는 배열로 되어있고 key는 직접 내부 배열의 인덱스가 될 수 있다. 이 배열을 버킷이라 한다.
- 인덱스를 구하기 위해서 해시 함수를 사용하는데, 이 때 동일 중복값이 발생하는 경우가 생긴다. 이것을 해시 충돌이라 하는데 해시 충돌을 방지하기 위해 Open Addressing 방식과 Separate Chaning 방식이 있다.
- HashMap은 해시 충돌 시 Seperate Chaining을 사용한다.
- Separate Chaning 방식은 동일한 해시값이 있으면 LinkedList로 관리하게 되는데, Java8에서는 LinkedList 원소가 8개 이상이면 Tree로 변경해서 관리하게 되고 다시 6개 이하가 되면 LinkedList로 변경하여 관리한다.


## Hash
#### Hashing 이란 뭔가요?
- 해싱은 가변 크기의 입력값에서 고정된 크기의 출력값을 생성해 내는 과정을 의미한다.

#### Hash에 대해서 설명해주세요
- Hash는 배열구조에 각 아이템의 Hash함수에 의해 만들어진 Hash값을 인덱스로 저장되는 자료구조로, 각 아이템의 Hash값을 통해 해당 값에 바로 접근할 수 있는 자료구조이며 Key-Value 한 쌍으로 구성된다.

#### Hash 충돌이 무엇이고 이 충돌을 피할 수 있는 방법은?
#### Hash 충돌이란? 
- 서로 다른 키 값이 해쉬 함수를 통해 같은 해쉬 값이 나오는 상황을 말한다.

#### Hash 충돌을 어떻게 해결하는가? 
- 해쉬 함수를 잘 짠다. 하지만 아무리 잘 짜도 비둘기집 원리에 의해 충돌은 불가피하다. 따라서 3의 처리가 필요하다.

#### Hash 충돌이 일어났을 때 어떻게 처리되는가? 
- open, close 어드레싱의 방법이 있다. 충돌이 일어났을 때 특별한 연산을 통해 비어있는 다른 인덱스를 찾는 방법과, 배열 안에 배열 혹은 연결 리스트로 계속 붙여나가는 방법 등이 있다.
  1. Open addressing : 해쉬 값과 실제 저장된 위치가 다를 수 있다. 즉 충돌이 일어나면 다른 인덱스에 저장하도록 조정한다.
       - 선형 탐사, 제곱 탐사, 이중 해쉬
  2. Close addressing : 해쉬값과 실제 저장된 위치는 다를 수 없다. 충돌이 일어나도 해당 위치에 저장한다. 다만 다른 방법을 써서 기존 값을 버리거나 덮어씌우는 멍청한 짓은 하지 않는다.
       - 버켓(배열), 체이닝(연결리스트)

#### 왜 Hashing을 해야하는지
- 평균 시간 복잡도가 O(1)로 매우 빠르기때문에 실무에서 자주 쓰이는 대표적인 자료구조이다.




## 큐, 스택
#### 큐, 스택 차이
- 스택은 LIFO(last in first out)이고, 큐는 FIFO(first in first out)이다.

#### 사용하는 예
- 스택: 함수의 콜스택, 문자열을 역순으로 출력할 때, 연산자 후위표기법, 웹 브라우저 방문기록, 실행취소, 수식의 괄호 검사
- 큐: 프로세스 관리, 캐시 구현, BFS, 우선순위가 같은 작업 예약

#### 큐를 이용해서 선입선출로 하고 있는데 긴급발송건이나 예약발송건이 있으면 먼저 보내야하는데 큐에서 가능할까?
- 우선순위 큐 사용




## Tree
#### Tree는 어떤 경우에 사용하나요?
- 계층적인 데이터 형태들은 트리에 저장하면 자연스럽게 표현된다.
<!-- - 정렬된 순서대로 데이터를 저장해야 할 때 -->

#### 다른 자료구조와 어떤 차이가 있는지
- Tree는 비선형구조인데 비선형구조는 선형구조와는 다르게 데이터가 계층적(혹은 망)으로 구성되어있다.
- 선형구조는 자료를 저장하고 꺼내는 것에 초점이 맞춰져 있고, 비선형구조는 표현에 초점이 맞춰져 있다.
- 예) 조직도, 족보

#### B-Tree에 대해 설명
- Tree의 높이를 완전히 동등하게 유지하는 알고리즘

#### 노드가 어떻게 되어있는지
- 하나의 노드에 다량의 데이터를 담을 수 있다.
- 노드의 최대 크기를 제한하여 한 번에 메모리에 할당되는 데이터의 수를 제한할 수 있는 구조이다.

#### 내부적으로 데이터가 어떻게 저장되는지
- 삽입 시 리프노드부터 채워야 함
- 리프노드 하나가 max degree에 도달하면 분할을 한다. 이 때 루트 노드가 아니였을 경우에는 서브 트리를 부모노드로 한 단계 올려준다.

#### B* Tree에 대해 설명해주세요
- B-Tree가 데이터 삽입 시 분열이 잦아 성능이 느려진다는 점을 개선하기 위한 알고리즘
- 삽입 시 인접한 형제 노드에 여유가 있는 경우 값들을 재배치하는 것을 우선시 한다.
- 형제 노드와 인접한 노드 값을 부모 노드로 올리고 부모 노드 값은 형제 노드로 넘겨서 max degree를 맞춰준다.
- 모든 형제 노드가 꽉 찼을 때 분열과 합병을 하게 된다.

#### B* Tree가 B-Tree와 다른 점이 뭔가요?
- 노드 간의 단순한 값의 재배치가 알고리즘적으로 더 단순하다는 것을 이용하여 형제노드에 값이 꽉 찰때까지 분열을 최대한 늦춤으로서 삽입 속도를 향상시킨다. 
- 또한 노드를 꽉 채울 때까지 기다리기 때문에 평균 공간 사용률이 늘어나는 장점이 있다.

#### B+ Tree에 대해 설명해주세요
- B-Tree로 특정한 값을 찾았을 때 그 값에서 부터 다른 값을 순차적으로 찾으려면 트리를 뒤져야 한다는 점을 개선하기 위한 구조이다. 
- 노드는 값을 찾기 위한 인덱스의 역할만 하고 실제 데이터는 리프노드에 모두 담고 있는 구조를 가지고 있다.

#### B+ Tree가 B-Tree와 다른 점이 뭔가요?
- 분열이 일어나는 경우에 부모노드가 되는 노드의 값을 오른쪽 자식노드에도 같이 담게 된다. 또한 왼쪽 자식 노드는 오른쪽 자식노드에 연결을 하게 된다. 
- 이렇게 반복하면 리프노드에는 모든 값이 담기고 그 값은 순서대로 정렬되어 서로 연결되므로 하나의 값을 찾으면 그 값을 기준으로 모든 값을 순서대로 바로 찾아볼 수 있다는 장점이 있다. 
- 다만, 리프노드에 데이터가 중복되어 들어가므로 공간 사용량은 늘어난다.

#### Binary Tree에 대해 알고 있나요?
- 하나의 부모노드가 가지는 자식노드가 최대 2개로 제한되는 트리구조이다.
- 일반적으로는 데이터를 정해진 규칙에 따라 저장하고 빠르게 찾는 검색용도에 많이 사용한다.

#### Binary Search Tree에 대해 설명해주세요
- 모든 부모노드가 왼쪽 자식노드에는 더 작은 값을 오른쪽 자식노드에는 더 큰 값을 가지는 형태를 하고 있다.
- 이러한 형태가 가지는 장점은 데이터를 찾을 때 배열보다 평균적인 탐색 속도가 빠르다는 점이다.
- 단점은 데이터를 그냥 쌓아두는 방법에 비해 데이터를 추가하거나 삭제하는 것도 규칙을 따라야한다는 점이다.

#### Binary Search Tree에서 검색속도가 가장 느린 케이스
- 한 쪽으로만 노드가 계속해서 연결 되었을 경우