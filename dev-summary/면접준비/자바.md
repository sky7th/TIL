#### java 특징

1.  운영체제에 독립적
    -   OS위의 JVM(Java Virtual Machine) 이라는 가상머신 위에서 자바가 실행되기 때문입니다.
    -   JVM을 사용하기 때문에 많은 메모리를 사용하고 실행속도 또한 빠르지 않은 단점이 있다.
2.  객체 지향 언어
    -   객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
3.  자동 메모리 관리
    -   자바로 작성된 프로그램이 실행되면, 가비지컬렉터가 자동적으로 메모리를 관리해준다.
    -   가비지 컬렉터: 시스템에서 더이상 사용하지 않는 동적 할당된 메모리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 시스템에서 가비지컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.
4.  네트워크와 분산처리를 지원
    -   다양한 네트워크 프로그래밍 라이브러리(Java API)를 통해 비교적 짧은 시간에 네트워크 관련 프로그램을 쉽게 개발할 수 있도록 지원한다.
5.  멀티쓰레드를 지원
    -   일반적으로 멀티쓰레드(multi-thread)의 지원은 사용되는 운영체제에 따라 구현방법도 상이하고 처리 방식도 다르다.
    -   자바에서 개발되는 멀티쓰레드 프로그램은 시스템과는 관계없이 구현가능하며, 관련되 라이브러리(Java API)가 제공되므로 구현이 쉽다.
6.  동적 로딩을 지원한다.
    -   자바는 동적 로딩을 지원하기 때문에 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다.
    -   일부 클래스가 변경되어도 전체 어플리케이션을 다시 컴파일하지 않아도 된다.
7.  기본 자료형을 제외한 모든 요소들이 객체로 표현

#### Java EE와 SE 차이

-   Java SE란 Java Platform Standard Edition의 약자로 데스크톱, 서버, 임베디드를 위한 표준 자바 플랫폼을 말합니다.
    
    -   안드로이드를 개발할 때 보통 Java SE로 개발을 합니다.
-   Java EE란 Java Platform EnterPrise Edition의 약자로 자바를 이용한 서버측 개발을 위한 플랫폼입니다.
    
    -   SE에 서버측을 위한 기능을 추가하여 SE의 모든 기능을 이용 할 수 있습니다.

#### JVM

-   정리가 잘 되어있는 블로그
    -   [마로의 Java(자바) 정리 - 8. 자바 메모리 구조](https://hoonmaro.tistory.com/19)
-   자바의 메모리 영역
    -   메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다. 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.
    -   스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리
    -   힙(Heap) : new 연산자를 통한 동적 할당된 객체들이 저장되며, Garbage 컬렉션에 의해 메모리가 관리되어 진다.

#### java에서 바이트코드

-   자바에서 코드를 컴파일하면 바이트코드 즉 (.class)형태로 출력이 되는데 이 Class형태는 JVM에 의해 런타임시완벽한 기계코드로 변경되어 실행됩니다.
-   바이트 코드를 완전한 기계코드로 변환하는 과정에서 일반적인 컴파일 언어보다 속도가 많이 느리다는 단점이 있습니다.

#### 객체지향 프로그래밍

-   객체지향이란
    
    -   시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용해 시스템을 분할하는 방법이다.
    -   자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
    -   객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
    -   객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 자율적으로 선택한다.
-   장점
    
    -   코드 재사용이 용이
        -   남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
    -   유지보수가 쉬움
        -   절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨.
    -   대형 프로젝트에 적합
        -   클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.
    -   신뢰성이 높은 프로그래밍을 가능하게 한다.
        -   제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
-   단점
    
    -   처리속도가 상대적으로 느림
    -   객체가 많으면 용량이 커질 수 있음
    -   설계시 많은 시간과 노력이 필요

#### 객체지향 언어의 특징

-   추상화 (모델링)
    -   어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
    -   불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다. (= 객체지향 관점에서 클래스를 정의하는 것.)
    -   복잡성을 다루기 위한 추상화의 두 차원
        1.  구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것
        2.  중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것
-   캡슐화 (정보은닉)
    -   객체의 필드(속성), 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것을 말한다.
    -   외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
    -   필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.
    -   자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.
-   상속과 인터페이스 (계층성)
    -   기존 클래스의 변수와 메소드를 그대로 가지면서 추가적인 기능도 가지는 클래스를 새로 만드는 것입니다. 복잡한 문제를 나누어서 공통 부분부터 구현하기 위해 사용합니다.
    -   자식(하위,파생) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것
    -   자식이 부모를 선택해서 물려 받는 것
    -   상속 대상: 부모의 필드와 메소드
    -   장점
        -   부모 클래스를 재사용해서 자식 클래스를 빨리 개발할 수 있다.
        -   반복된 코드의 중복을 줄여준다.
        -   유지 보수의 편리성을 제공해 준다.
        -   객체의 다형성을 구현할 수 있다.
-   다형성 (사용편의성, 모듈화)
    -   서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킨다.
    -   [https://m.blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220979244668&proxyReferer=https:%2F%2Fwww.google.com%2F%5D](https://m.blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220979244668&proxyReferer=https:%2F%2Fwww.google.com%2F%5D)(\[JAVA/자바\] 다형성(polymorphism)의 개념/의미/예제)
-   동적 바인딩
    -   실행 시간(runtime)에 성격이 결정되는 것

#### 추상클래스와 추상메서드

-   추상클래스
    -   클래스가 설계도라면 추상클래스는 ‘미완성 설계도’
    -   추상메서드(미완성 메서드)를 포함하고 있는 클래스
    -   일반메서드가 추상메서드를 호출 할 수 없다.
    -   완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
    -   다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.
-   추상메서드
    -   선언부만 있고 구현부(몸통, body)가 없는 메서드
    -   꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용된다.
    -   추상클래스를 상속받는 자손클래스에서 추상메서드의 구현부를 완성해야한다.

#### 인터페이스

-   정의한 메소드를 구현하지 않아도 되고 인터페이스를 상속받는 클래스에서 인터페이스에 정의된 메소드를 구현하면 된다.
-   인터페이스의 특성
    -   인터페이스의 사용법만 알고 있으면 대상의 내부 구조나 동작 방법을 몰라도 상호작용이 가능하다.
    -   인터페이스가 변경되지 않고 단순히 내부 구성이나 작동 방식이 변경되는 것은 인터페이스 사용자에게 아무런 영향도 미치지 않는다.
    -   인터페이스가 동일하기만 하다면 어떤 대상과도 상호작용할 수 있다.
-   일종의 추상클래스. 추상클래스(미완성 설계도)보다 추상화 정도가 높다
-   실제 구현된 것이 전혀 없는 기본 설계도.
-   추상메서드와 상수만을 멤버로 가질 수 있다.
-   인스턴스를 생성할 수 없고, 클래스 작성에 도움을 줄 목적으로 사용된다.
-   미리 정해진 규칙에 맞게 구현하도록 표준을 제시하는데 사용된다.
-   [https://m.blog.naver.com/heartflow89/220969525191](https://m.blog.naver.com/heartflow89/220969525191)(\[JAVA/자바\] 인터페이스(interface) 구성멤버, 구현, 상속)

#### 추상클래스와 인터페이스의 차이

-   인터페이스와 추상 클래스는 존재 목적이 다르다.
-   추상 클래스는 그 추상 클래스를 상속받아서 기능을 이용하고, 확장시키는 데 있고, 다중 상속의 모호성 때문에 하나만 상속받을 수 있다.
-   인터페이스는 함수의 껍데기만 있는데, 그 이유는 그 함수의 구현을 강제하기 위함이다. 구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있다.

#### extends와 implements의 차이

-   extends
    -   클래스를 확장하는 것이다.
    -   일반 클래스와 abstract 클래스 상속에 사용된다.
    -   class가 class를 상속받을 때, interface가 interface를 상속 받을 때 사용
    -   특징: 클래스 한 개만 상속 받을 수 있고 부모 클래스의 기능을 사용한다.
-   implements
    -   인터페이스를 구현하는 것이다.
    -   interface 상속에 사용된다.
    -   class가 interface 내용을 구현할 때 사용
    -   특징: 여러개 사용 가능하고, 설계 목적으로 구현 가능하다. implements한 클래스는 implements의 내용을 다 사용해야 한다.

#### 클래스와 객체

-   클래스의 정의
    -   어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것
-   클래스의 용도
    -   클래스는 객체를 생성하는데 사용된다.
-   객체의 정의
    -   클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

#### getter, setter 를 사용하는 이유

-   메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있기 때문

#### 오버로딩과 오버라이딩

-   오버로딩: 하나의 클래스에 같은 이름의 메서드를 여러 개 정의하는 것
-   오버라이딩: 조상클래스로부터 상속받은 메서드의 내용을 상속받는 클래스에 맞게 변경하는 것

#### 제어자

-   클래스나 멤버변수와 메서드에 주로 사용되며 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.
    
-   접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.
    
-   static (클래스의, 공통적인)
    
    -   클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
    -   객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)
    -   멤버변수:
        -   모든 인스턴스에 공통적으로 상용되는 클래스변수가 된다.
        -   클래스변수는 인스턴스를 생성하지 않고도 사용가능하다.
        -   클래스가 메모리에 로드될 때 생성된다.
    -   메서드:
        -   인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
        -   static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.
-   final (마지막의, 변경될 수 없는)
    
    -   클래스:
        -   변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
        -   final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
    -   메서드:
        -   변경될 수 없는 메소드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
    -   멤버변수, 지역변수:
        -   변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.
-   abstract (추상의, 미완성의)
    
    -   멤버변수:
        -   클래스 내에 추상메서드가 선언되어 있음을 의미한다.
    -   메서드:
        -   선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다.
-   접근 제어자
    
    -   private: 같은 클래스 내에서만 접근이 가능하다.
    -   default: 같은 패키지 내에서만 접근이 가능하다.
    -   protected: 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
    -   public: 접근 제한이 전혀 없다.

#### 제네릭

-   제네릭 타입을 이용해서 컴파일 과정에서 타입 체크를 할 수 있다.
-   제네릭은 클래스와 인터페이스, 메소드를 정의할 때 타입 파라미터로 사용한다.
-   장점
    1.  컴파일할 때 타입을 체크해서 에러를 사전에 잡을 수 있다.
    2.  컴파일러가 타입캐스팅을 해주기 때문에 개발자가 편리하다.
    3.  타입만 다르고 코드의 내용이 대부분 일치할 때, 코드의 재사용성이 좋아진다.

#### String, StringBuilder, StringBuffer의 차이

-   String 객체
    -   immutable 합니다. 즉 한번 생성이 되면 변경이 불가능 합니다.
    -   예를 들면 String 2개를 연결하는 작업을 할 때에 새로운 String을 객체를 이용하여 문자열을 참조하게 됩니다.
-   StringBuffer
    -   멀티쓰레드 환경에서 동기화를 보장한다.
-   StringBuilder
    -   멀티쓰레드 환경에서 동기화를 보장하지 않는다.
-   name = name + “홍”; 구문이 실행될 때 실제로는 스트링 버퍼를 새로 생성해서 name이 가리키는 “길동”을 만들어주고 스트링 버퍼의 append 함수를 이용하여 “홍” 를 붙여준다. 그렇게 완성된 스트링 버퍼값을 메모리에 올리고 name은 다시 이 값을 참조하게 된다. 스트링 버퍼는 char타입의 배열로 되어 있어서 한글자 한글자를 append할 수 있다. 그 와중에 생겨난 메모리 안의 “길동” 이라는 값과 “홍”라는 값은 가비지 컬렉터가 가지고 있다가 버립니다.

#### DAO와 DTO

-   DAO: Data Access Object의 약자로 간단히 데이터베이스의 데이터에 접근을 위한 객체이다. 데이터베이스에 접근을 하기위한 로직과 비즈니스 로직을 분리하기 위해서 사용한다. DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.
    
-   DTO: Data Transfer Object의 약자로 VO(Value Object)로 바꾸어 말할 수 있는데 계층간 데이터 교환을 위한 JavaBean을 말합니다. 여기서 말하는 계층이란 Controller, View, Business Layer, Persistent Layer를 말하며 각 계층간 데이터 교환을 위한 객체를 DTO 또는 VO라고 부릅니다. 그런데 VO는 동일한 개념이지만 read only 속성을 가집니다.

### 프로세스와 스레드

-   Process(프로세스) - 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함한다.)
-   Thread(쓰레드) - 프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다
-   Thread 장점
    -   빠른 프로세스 생성
    -   적은 메모리 사용
    -   쉬운 정보 공유
-   Thread 단점
    -   교착상태에 빠질 수 있다.
        -   교착상태 : 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.
-   Thread와 Process 차이
    -   여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 "실행중인 프로그램" 이라는 뜻으로 쓰인다.
    -   이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.
-   자바에서 쓰레드를 구현하기 위한 2가지 방법
    -   lang 패키지내에 구현되어있는 Thread 클래스를 상속받거나 Runnable 인터페이스를 상속받아 run 메소드를 재정의하여 구현합니다.

#### 스트림

-   자바에서 입출력을 수행하려면, 즉 어느 한쪽에서 다른 쪽으로 데이터를 전달하려면, 두 대상을 연결하고 데이터를 전송할 수 있는 무엇가가 필요한데 이것을 스트림(stream)이라고 정의했다.
-   스트림은 단방향통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다. 그래서 입력과 출력을 동시에 수행하려면 입력을 위한 입력스트림(input stream)과 출력을 위한 출력스트림(output stream), 모두 2개의 스트림이 필요하다.

#### 직렬화

-   직렬화(serialization)란 객체를 데이터 스트림으로 만드는 것을 뜻한다.
-   객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없다. 그래서 객체에 저장된 데이터를 스트림에 쓰기(write)위해 연속적인(serial) 데이터로 변환하는 것을 말한다. 반대로 스트림으로부터 데이터를 읽어서 객체를 만드는 것을 역직렬화(deserialization)라고 한다. ( 객체의 인스턴스 변수들의 값을 일렬로 나열하는 것 )

#### serialVersionUID를 선언해야 하는 이유
- 자바가상기계 (JVM)은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여한다. 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당한다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수도 있습니다. 이런 문제를 해결하기 위해 SerialVerionUID를 사용한다.
- 간단명료하게 serialVersionUID값을 저장할 때 클래스 버전이 맞는지 확인하기 위한 용도다.
- 만약 직렬화할 때 사용한 serialVersionUID의 값과 역직렬화 하기 위해 사용했던 serialVersionUID값이 다르다면 InvalidClassException이 발생할 수 있다.

#### 동기화를 지원하는 자료구조
- Vector, HashTable

#### 언제, 왜 필요한지
- 멀티쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하기 위해서는 동기화가 필요하다.
- 싱글 스레드 프로그램에서는 한 개의 스레드가 객체를 독차지해서 사용하면 되지만, 멀티 스레드 프로그램에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있다.
- 이 경우, 만일 쓰레드A가 작업하던 도중에 다른 쓰레드B에게 제어권이 넘어갔을 때, 쓰레드A가 작업하던 공유 데이터를 쓰레드B가 임의로 변경하였다면, 다시 쓰레드A가 제어권을 받아서 나머지 작업을 마쳤을 때 원래 의도했던 것과는 다른 결과를 얻을 수 있다.


#### 스레드 세이프하다는 것은 어떤 의미인가요?
- 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다.

#### 리플렉션에 대해 설명해주세요
- 리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말합니다. 즉 동적인 언어의 특징이라 말 할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.

#### pojo가 무엇인가요?
- Plain Old Java Object. 간단히 포조 라는 말 그대로 해석하며 ㄴ오래된 방식의 자바 오브젝트로서 J2EE등의 중량 프레임워크들을 사용하면서 해당 프레임워크에 종석된 무거운 객체를 만들게 된 것에 반발하여 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 지칭하는 말로 사용되었다.

#### Servlet

-   Servlet
    -   Servlet은 웹에서 Java 프로그래밍을 구현하기 위해서 탄생했다. (웹 개발을 위해 만든 표준)
    -   Java로 구현된 CGI(Common Gatway Interface)라고 말한다.
    -   HTTP Protocal 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속하여 개발하며, Servlet은 Container에 의해서 실행되고 관리된다.
    -   HTML 변경 시 Servlet을 재컴파일 해야하는 단점이 있다. (코드 수정 -> 컴파일 -> 클래스 파일)
-   Servlet Container
    -   HTTP 요청을 받아서 Servlet을 실행시키고, 그 결과를 사용자 브라우저에게 전달해주는 기능을 제공하는 컴포넌트이다.
    -   Servlet을 실행하고, 생명주기를 관리하는 역할을 한다.
    -   Servlet과 웹 서버(Apache, ngin 등)가 서버 통신을 할 수 있는 방법을 제공한다.
    -   멀티쓰레드를 지원하여 클라이언트의 다중 요청을 자동적으로 처리해준다.
    -   대표적인 Container에는 Tomcat, JBoss 등이 있다.

#### Servlet 실행 순서

1.  사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.
2.  Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.
3.  사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다. (DD를 참조하여 분석)
4.  컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.
5.  doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다.
6.  응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.

\*DD (배포서술자, Deployment Descriptor) = web.xml

#### JSP

-   JSP(JavaServer Pages)는 자바 언어를 기반으로 하는 스크립트 언어로서 자바가 제공하는 기능을 그대로 사용할 수 있다. 또한 ASP, PHP처럼 스크립트 기반으로 개발되어 서버 페이지를 휠씬 쉽게 작성할 수 있으며 서블릿과 함께 구동함으로써 서블릿의 기능을 그대로 사용할 수 있으며, 자바빈즈(JavaBeans), EJB같은 기술로 보다 강력한 객체 지향적 지원이 가능하게 되었다. 또한 JSTL을 지원하게 되면서 웹 프로그램의 가독성이 좋아지고 유지 및 보수가 휠씬 쉬워지는 장점이 있다.