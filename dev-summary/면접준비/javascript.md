#### 함수형 프로그래밍이란
- 함수를 이용해서 사이드 이펙트 없도록 선언형 프로그래밍을 이용하는 것이다.

#### 함수형 프로그래밍의 컨셉
- 변경 가능한 상태를 불변상태(Immutab)로 만들어 SideEffect를 없애자.
- 모든 것은 객체이다.
- 코드를 간결하게 하고 가독성을 높여 구현할 로직에 집중 시키자.
- 동시성 작업을 보다 쉽게 안전하게 구현 하자.

#### OOP와 함수형 프로그래밍의 차이
- 객체지향과 함수형의 차이는 상태를 관리하는 점이다. 
- 객체지향의 경우 객체 안에 상태를 저장한다.
- 함수형 프로그래밍은 이런 상태를 제어하기보다는 상태를 저장하지 않고 없애는데 주력한다. 함수라는 것 자체가 입력값이 들어가면 이에 따른 특정한 출력값이 나오는 것으로 상태를 저장하지 않는다.
> 객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다. - 마이클 페더스

#### 순수함수란
- 동일한 입력에는 항상 같은 값을 반환해야 한다.
함수의 실행은 프로그램의 실행에 영향을 미치지 않아야 한다. (Side effect 가 없어야 한다)
- 순수 함수를 호출하면 프로그램의 어떠한 변화도 없고, 입력 값에 대한 결과를 예상할수 있어서 테스트하기가 쉽다.


#### 브라우저의 렌더링 과정


#### Promise란?
- Promise란 향후에 언젠가 사용하게 될 값을 생산해내는 객체이다. 
- 여기서 값은 얻을 수 있거나(resolved), 혹은 값을 얻지 못하는 대신에 그렇게 된 이유를 얻게 된다(rejected).


#### 클로저가 무엇이고 왜 쓰는지 설명하고 간단하게 코드로 구현해보아라.
- 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다.
- 중첩된 함수 구조에서 바깥 함수의 변수를 가져다 쓰는 내부 함수와, 그 변수가 저장되는 저장소를 포괄하여 클로저라고 부릅니다. 
- 클로저를 사용하는 이유
  - 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
  - 전역 변수의 사용을 억제 하기위해
  - 정보를 은닉하기 위해 
  - 실수를 줄이기 위해

#### 불변성이 무엇인지와 가변성을 해결하기 위한 방법을 제시하라.
- 불변성이란, 원래의 값을 변경할 방법이 없는 성질을 말하며, 원시 타입들의 모든 값은 불변성을 가지고 있습니다. 이렇게 불변성을 가지는 값을 불변인 값이라고합니다. 이런 불변인 값을 바꾸기 위해서는 다른 값을 다시 대입하는 방법밖에 없습니다.
- 이 불변성과 대비되는 성질을 가변성이라하는데, 참조 타입인 객체가 이에 해당합니다. 객체는 가변이기 때문에 어디서 어떻게 변경될지 모른다는 불안함이 존재하는데, 이를 해결하기위해 Object.freeze를 쓸 수도 있지만 immutable.js 혹은 immer.js 같은 라이브러리를 더 많이 씁니다. 이런 라이브러리를 쓰면 객체의 내용을 변경하면 아예 새로운 객체를 반환해주는 방식으로 동작하여 원본 객체를 마치 불변인 값인양 다룰 수 있게됩니다.

#### 화살표 함수와 일반함수와의 차이점은?
- 일반 함수가 생성자로 사용될 수 있는 것과 달리 화살표 함수는 prototype 속성을 갖고 있지 않으며 생성자로 사용될 수 없습니다.
- 화살표함수는 스스로의 this, arguments, super를 가지지 않습니다.
- 일반 함수는 this가 함수를 호출하는 객체에 의해 결정되지만, 화살표함수는 어떻게 선언되느냐에 따라 this가 지정됩니다(주변 스코프에에 묶인다). 때문에 화살표는 this를 바꿀 수 없고, bind&call&apply 메소드를 사용할 수 없습니다.

#### 생성자의 메서드에 화살표 문법을 사용하면 어떤 이점이 있나요?
- 생성자 내부에서 화살표 함수를 메소드로 사용하는 주된 장점은, 함수 생성시 this의 값이 설정되고 그 이후에는 변경할 수 없다는 것입니다.
- 생성자가 새로운 객체를 생성하는데 사용될 때, this는 항상 그 객체를 참조할 것입니다.
- 따라서 화살표 함수를 앱의 다른 부분으로 전달하는 경우에도 컨텍스트 변경에 대해 걱정할 필요가 없습니다.

#### 자바스크립트에서 this는 무엇인지?
- this는 생성자 혹은 메소드에서 어떠한 객체를 가리킬 때 사용하는 키워드입니다. this가 가리키는 객체는 상황에 따라 달라지는데,
  - 전역 공간에서 this - window 객체
  - 함수 내부에서 this - window 객체
  - 메소드 호출 시 - 메소드 호출 주체
  - 콜백에서 this - window - 하지만 this를 명시하거나 this를 바인딩해서 넘기면 그에 따른다.
  - 생성자 함수에서 this - 인스턴스

  위 상황으로 나뉠 수 있습니다.

#### == 와 === 차이
- ==연산자는 동등 연산자로, 피연산자가 서로 다른 타입이면 타입을 강제로 변환하여 비교합니다. 
- ===연산자는 일치 연산자로, 형 변환을 하지 않고 비교하기 때문에 두 피연산자를 더 정확하게 비교합니다. 
- 엄격한 비교를 위해 ===만을 쓰는 것이 권장되지만, null, undefined 체크시에는 ==를 써도 무방합니다.

#### 호이스팅이란?
- 호이스팅이란 var 변수 선언부나 함수 선언식이 선언과 동시에 해당 스코프의 최상단으로 끌어올려지는 현상을 가리킵니다.

#### function foo() {}와 var foo = function() {} 사이에서 foo 사용법의 차이에 대해 설명하시오.
- 전자는 함수 선언식으로 foo()라는 함수는 호이스팅되며, 후자는 함수 표현식으로 foo라는 변수의 선언부는 호이스팅 되지만 대입된 함수는 호이스팅되지 않습니다.

#### let, var 또는 const를 사용하여 생성된 변수들의 차이점은 무엇인가요?
- var : 함수스코프 / 재대입, 재선언, 호이스팅 모두 됨
- let : 블록스코프 / 재대입 가능, 재선언, 호이스팅 안 됨
- const : 블록스코프 / 재대입, 재선언, 호이스팅 안 됨

#### Function.prototype.bind에 대해 설명하시오.
- bind 메소드는 function 키워드로 선언된 함수 내부의 this를 내가 원하는 객체로 지정할 수 있게하는 메소드 입니다.
- bind() 메소드는 호출될 때, this 키워드가 주어진 인자 값으로 설정되고, 새로운 함수가 호출될 때, 앞쪽의 매개변수도 자신의 인자를 사용해 미리 순서대로 채워놓은 새로운 함수를 반환합니다.

#### 엄격모드가 무엇이고 어떻게 사용하는 것이지?
- 엄격 모드란, 프로그래머가 실수하기 쉬운 몇 가지 문법에 대해 제약사항을 추가해주는 자바스크립트의 기능입니다. 
- 예를 들어, 프로그래머의 실수로 this가 전역 객체를 가리키게 될 시 이를 막고 this는 undefined를 반환하게 해줍니다. 
- 엄격 모드를 쓰기 위해서는 파일 혹은 함수 제일 위에 `'use strict';`를 작성해주면 되지만, ES2015 모듈을 이용해 작성된 코드는 항상 엄격 모드로 동작하기 때문에, `use strict';`를 붙여주지 않아도 엄격 모드로 동작합니다.

#### 고차 함수의 정의는 무엇입니까?
- 고차 함수의 정의는 함수를 인수로 받는 함수, 혹은 함수를 반환하는 함수입니다.
- 고차 함수는 반복적으로 수행되는 어떤 연산을 추상화하기 위한 것입니다.

#### 자바스크립트 원시타입은 몇 개이고 전부 말하라.
- 총 6개며, `null`, `undefined`, `number`, `string`, `boolean`, `symbol`입니다.

#### Iterable과 Iterator이 무엇인가?
- Iterable이란 순회 가능한 객체를 말하고, Iterator란 Iterable 객체의 요소를 탐색하기 위한 포인터이다. 
- Iterator 객체 내부에는 next 메소드가 존재하고, next메소드는 value 속성과 done 속성이 들어있는 객체를 반환한다.

#### Generator함수에 대해 설명하세요
- iterable 객체를 반환해주는 특별한 함수입니다. iterable하지 않은 값을 iterable한 객체로 생성하거나 새로운 iterable 객체를 생성하고 싶을 때 가장 쉽게 사용할 수 있는 방법이기도 합니다.
function* 키워드로 함수를 만들 수 있으며 yield를 통해 값을 넘겨줄 수 있습니다.

#### Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가?
- 클래스란 비슷한 객체를 원하는 만큼 만들어낼 수 있는 생성자 함수가 하는 기능을 좀 더 간결하고 깔끔한 문법으로 구현할 수 있게끔해주는 오브젝트입니다. 
- 애초에 javascript에서의 Class는 다른 언어에서의 클래스처럼 실제로 상속기능이 있는 것이 아닌 prototype을 이용해 상속 기능을 구현한 것이기 때문에, ES5 스펙으로도 클래스를 구현할 수 있습니다.

#### ES6 클래스와 ES5 함수 생성자의 차이점은 무엇입니까?
- 클래스는 함수로 호출될 수 없다.
- 클래스 선언은 `let`과 `const` 처럼 블록스코프에 선언되며, 호이스팅이 일어나지않는다.
- 클래스의 메소드 안에서 `super` 키워드를 사용할 수 있다.

#### 클래스 상속보다 객체 구성을 선호한다는 것은 무엇을 의미하는가?
- 클래스 상속을 이용한 코드 재사용보다 작은 단위의 함수를 객체로 모아 조합하는 방식이 좋다.

#### 동기와 비동기의 차이점을 설명하라
- 동기는 작업이 시작되면 해당 작업이 끝날 때까지 다른 작업을 유보하는 것이고
- 비동기는 작업이 시작되고 작업이 끝나지 않은 도중이라도 다른 작업을 시작할 수 있다는 차이점이 있다.

#### Promise란 무엇이며 코드가 어떻게 구성되어있는가
- 언젠간 끝나는 작업의 결과값을 담는 객체이다. 
- 프로미스 생성자는 콜백을 인수로 받는다. 
- 콜백의 첫번째 인수는 resolve고, 콜백안에서 resolve에 인수로 넘겨준 값이 이 프로미스 객체의 결과값이 된다. 
- 두번째 인수는 reject고 예외 상황에서의 콜백을 작성한다.

```js
const p = new Promise(resolve => {
  setImeout(() => {
    resolve(value); //resolve에 인수로 준 값이 promise 객체의 결과값이 된다.
  }, ms);
});
```

#### Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명하라
- Promise 장점
  - 프로미스는 then 메소드를 사용하여 콜백을 작성해줄 수 있고, 
  - 작성되는 문법이 콜백과 달리 깔끔하여 비동기식 코드를 동기식 코드처럼 작성할 수 있다.
  - Promise.all()을 사용하여 병렬 비동기 코드를 쉽게 작성할 수 있다.
- 콜백은 함수의 인자로 들어가는 함수를 말하며, 비동기식 코드를 콜백으로 작성하게되면 콜백 지옥에 빠질 수 있다는 단점이 있다.

#### Async, Await가 무엇이며, 사용해본 경험이 있는가
- 함수 앞에 async를 붙이면 해당 함수는 비동기 함수가 된다. 
- 이 비동기 함수 내부에서 await를 사용할 수 있는데, await를 쓰면 뒤에 오는 Promise(를 반환하는 함수)가 결과값을 가질 때까지 함수를 잠시 멈추고, Promise 통에 값이 채워지면 함수를 다시 실행하여 값을 반환한다.

#### 이벤트 루프란 무엇입니까?
- 이벤트 루프는 콜 스택을 모니터하고 태스크 큐에서 수행할 작업이 있는지 확인하는 단일 스레드 루프입니다. 콜 스택이 비어 있고 태스크 큐에 콜백 함수가 있는 경우, 함수는 큐에서 제거되고 실행될 콜 스택으로 푸시됩니다.
- 호출 스택에서 작업을 처리하고, 오래 걸리는 작업은 브라우저에게 위임하고 다음 호출 스택의 작업을 처리ing하며, 브라우저에 위임된 작업이 끝나 작업 큐에 들어온 뒤 호출 스택이 빌 때까지 기다렸다 호출 스택에 들어가 처리되는 이 단일 스레드 루프를 이벤트 루프라고 한다.

#### function Person(){}, var person = Person(), var person = new Person() 의 차이점은 무엇입니까?
- 첫번째는 Person이라는 함수를 단순히 정의한 함수 선언식이고, 
- 두번째는 person이라는 변수에 Person함수 값을 대입한 것이고, 
- 마지막은 Person() constructor가 person이란 이름의 인스턴스을 생성한 것 입니다

#### 호스트 객체와 내장 객체의 차이점은 무엇입니까?
- 내장 객체는 이미 지정되어 있는 Array, String, Object 등등과 같은 객체입니다.
- 호스트 객체는 window, XMLHTTPRequest 등과 같이 런타임 환경 (브라우저 또는 노드)에 의해 제공됩니다.

#### 프로토타입 상속이 어떻게 작동하는지 설명하세요.
- 프로토타입 상속은 실제 상속을 받았다기 보다는 연결되어있는 프로토타입에 존재하는 속성을 공유할 수 있기 때문에 이것을 상속이라고 표현하는 것인데, 해당 객체에 불러온 속성이 없으면 연결된 프로토타입 객체로 가서 해당 속성을 찾아보고, 또 속성이 없으면 그 프로토타입 객체에 연결된 프로토타입 객체로 가서 속성을 찾아보는 방식이며, 이를 프로토타입 체인이라고 합니다.

#### DOM에 대해서 설명하세요.
- html파일로 만들어진 웹 문서를 브라우저에 렌더링 하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 변환하여 메모리에 보내줘야하는데, 
이 구조로 변환하는 단계를 parsing이라고 하고, 파싱 단계를 거쳐 변환된 모습인 '브라우저가 이해할 수 있는 구조 모델'을 DOM이라고 한다.

#### 이벤트 위임에 대해 설명하세요.
- 부모 요소에 event 리스너를 붙여주면, 자식 요소가 이벤트 버블링 단계에서 부모 요소에 있는 이벤트를 발생시킬 수 있는 것을 이용해 이벤트를 하나하나 등록하는 것이 아니라 부모에게 이벤트를 위임 하는 방법
- 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간이 줄어듭니다.

#### event bubbling과 event capturing에 대해 설명하세요.
- 버블링 - 이벤트가 발생한 target에서 시작하여 상위 요소로 이벤트 flow가 옮겨가는 것
- 캡쳐링 - 이벤트가 발생한 target의 상위요소에서 시작하여 target의 지점으로 이벤트 flow가 내려오는 것

#### preventDefault와 stopPropagation의 차이점에 대해 설명하세요.
- preventDefault() : 어떠한 태그의 기본 이벤트 동작을 취소한다.
- stopPropagation() : 이벤트 전파(버블링, 캡쳐링)를 중단한다.

#### mouseover, mouseout 과 mouseenter, mouseleave의 차이점
- mouseover & mouseout - 이벤트 버블링이 적용되는 이벤트이기 때문에, 자식 요소에서도 이벤트가 실행된다.
- mouseenter & mouseleave - 이벤트 버블링이 적용되지 않으며, 오로지 이벤트가 발생한 target에서만 이벤트가 실행됩니다.

#### Ajax란 무엇인가 ?
- XHR 객체를 이용하여 서버와 상호작용하게 되면 서버와 통신 할 때마다 전체 페이지를 새로 고치지 않고 페이지의 일부만을 위한 데이터를 로드할 수 있다.
- Ajax는 이 XHR객체를 이용하여 JavaScript에서 클라이언트와 서버간에 비동기 통신 형태로 XML 데이터를 주고 받는 기술 그 자체라고 할 수 있다.

#### Ajax를 사용하면 문제가 있다. 그 문제는 무엇인가?
- 히스토리관리가 되지 않는다.
- 연속으로 데이터를 요청하면 서버 부하가 증가한다.
- XHR을 통해 통신하는중 진행정보가 보이지 않습니다.
- 바이너리 데이터를 보내거나 받을수 없다.
- 같은 서버에 있는 주소로만 ajax요청을 할 수 있다.

#### 그 문제를 해결하려면 어떻게 해야하는가?

#### 자바스크립트 엔진이 무엇인가?
- 자바스크립트 엔진은 자바스크립트 코드를 읽고 컴파일하는 가상머신이다. 대표적으로는 크롬의 V8 엔진이 있다.

#### V8 의 특징
- V8 엔진은 C++ 로 작성 되었으며, ECMA-262 에 기재된 ECMAScript 및 WebAssembly 를 처리할 수 있다.
- JavaScript 소스 코드를 컴파일 하고, 실행한다.
- 생성하는 Object 를 메모리에 할당한다.
- 가비지 콜렉션을 이용해 더 이상 사용되지 않는 Object 의 메모리를 해제한다.
- Hidden Class 를 이용해 빠르게 프로퍼티에 접근한다.
- TurboFan 을 이용해 최적화된 코드로 만들어 속도 및 메모리를 최적화한다.

#### 스크립트의 속성 중에서 async 와 defer의 공통점과 차이점은?
- 둘 다 HTML을 파싱하면서 동시에 스크립트를 가져온다. 예전과 다르게 HTML파싱 작업은 일시정지 되지않는다.
- async는 HTML파싱 중에라도 스크립트가 준비되면 될 때마다 즉시 실행한다. 실행 순서가 다운로드 완료 시점에 의해 결정되므로 유의해야한다.
- defer는 HTML파싱 중에 스크립트 다운로드가 완료되더라도 바로 실행되지 않고, HTML파싱(구문분석)이 완료되면 스크립트가 실행된다. async와는 다르게 호출된 순서대로 실행된다.

#### Javascript 모듈 패턴(Javascript module pattern)"이 무엇인지 설명을 해주시고, 언제 사용하는지도 말씀해주시기 바랍니다.
- 코딩을 할 때 기능별로 코드를 분리해서 모아놓는 것을 모듈이라고 하는데, 모듈패턴은 이 모듈을 정의하는 방법 중 하나입니다.
- 네임스페이스 이용하여 함수 이름이나 변수가 출동을 예방할수 있습니다.
- 주로, private한 변수나 메소드를 구현하고 싶을 때 사용합니다.

#### this가 JavaScript에서 어떻게 작동하는지 설명하세요.
- 함수를 호출할 때 new 키워드를 사용하는 경우, 함수 내부에 있는 this는 완전히 새로운 객체입니다.
- apply, call, bind가 함수의 호출/생성에 사용되는 경우, 함수 내의 this는 인수로 전달된 객체입니다.
- obj.method()와 같이 함수를 메서드로 호출하는 경우, this는 함수가 프로퍼티인 객체입니다.
- 함수가 자유함수로 호출되는 경우, 즉, 위의 조건 없이 호출되는 경우 this는 전역 객체입니다. 브라우저에서는 window 객체입니다. 엄격 모드('use strict') 일 경우, this는 전역 객체 대신 undefined가 됩니다.
- 위의 규칙 중 다수가 적용되면 더 상위 규칙이 승리하고 this값을 설정합니다.
- 함수가 ES2015 화살표 함수인 경우 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 this값을 받습니다.

#### .forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요? 왜 둘 중 하나를 선택할 것인가요?
- .forEach와 .map()의 가장 큰 차이점은 .map()이 새로운 배열을 반환한다는 것입니다. 결과가 필요하지만 원본 배열을 변경하고 싶지 않으면, .map()이 확실한 선택입니다. 단순히 배열을 반복할 필요가 있다면, forEach가 좋은 선택입니다.

#### 내장 JavaScript 객체를 확장하는 것이 좋은 생각이 아닌 이유는 무엇인가요?
- 내장/네이티브 JavaScript 객체를 확장한다는 것은 prototype에 속성/함수를 추가한다는 것을 의미합니다. 이것은 처음에는 좋은 생각처럼 보일 수 있지만 실제로는 위험합니다. 여러분의 코드가 동일한 contains 메소드를 추가함으로써 Array.prototype을 확장하는 여러가지 라이브러리를 사용한다고 상상해보십시오. 이러한 구현은 메소드를 서로 덮어쓰게 되며, 이 두 메소드의 동작이 동일하지 않으면 코드가 망가질 것입니다.
- 네이티브 객체를 확장할 수 있는 유일한 경우는 polyfill을 만들 때입니다. JavaScript 사양의 일부이지만, 오래된 브라우저이기 때문에 사용자 브라우저에 없을 수도 있는 메서드에 대한 고유한 구현을 제공해야할 경우 뿐입니다.

#### document load 이벤트와 document DOMContentLoaded 이벤트의 차이점은 무엇인가요?
- DOMContentLoaded 이벤트는 스타일시트, 이미지, 서브프레임 로딩을 기다리지 않고, 초기 HTML 문서가 완전히 로드되고 파싱되면 발생합니다.
- window의 load 이벤트는 DOM과 모든 종속 리소스와 에셋들이 로드된 후에 ​​발생합니다.

#### JavaScript와 관련하여 same-origin 정책을 설명하세요.
- same-origin 정책은 JavaScript가 도메인 경계를 넘어서 요청하는 것을 방지합니다. origin은 URI 체계, 호스트 이름, 포트 번호의 조합으로 정의됩니다. 이 정책은 한 페이지의 악의적인 스크립트가 해당 페이지의 DOM을 통해 다른 웹 페이지의 중요한 데이터에 접근하는 것을 방지합니다.

#### JavaScript로 컴파일되는 언어로 JavaScript 코드를 작성하는 경우의 장단점은 무엇인가요?
- JavaScript로 컴파일되는 언어의 예로 CoffeeScript, Elm, ClojureScript, PureScript, TypeScript가 있습니다.
- 장점
  - JavaScript의 오랜 문제점들을 해결하고 JavaScript 안티-패턴을 방지합니다.
  - 정적 타입은 시간 경과에 따라 유지 관리해야 하는 대규모 프로젝트에서 훌륭합니다(TypeScript의 경우).
- 단점
  - 브라우저는 오직 JavaScript만 실행하기 때문에 빌드/컴파일 프로세스가 필요하며 브라우저에 제공되기 전에 JavaScript로 코드를 컴파일해야 합니다.

#### 타입스크립트를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라
- Typescript는 동적타입언어인 Javascript의 약점을 보완하기 위해서 타입을 지정해주는 것이다. 
- 타입이 필요한 이유는 결론은 메모리를 절약하기 위해서이다. 메모리에 저장된 것을 읽어들일때, 값을 메모리에 저장할때, 값이저장되어있는 것을 참조할때의 크기들을 알아야 하기 때문이다.
- 또한, 에러를 잡기가 쉬워지고, 다른 동료와 협업 할때 코드의 예측도 가능해지고, 코드에디터의 도움을 더 받을 수 있다. 리액트의 경우 (브라우저는 javascript밖에 모르기 떄문에) tsx파일을 javascript로 변환하는 트랜스파일링이 필요하다. 이때 변환하는 과정에서 에러를 잡을 수 있는데 이것은 런타임에 오류를 잡는 것보다 훨씬 좋다. 또한, Babel을 안써도 된다.

#### 오브젝트 속성이나 배열 항목을 반복할 때 사용하는 언어 구문은 무엇인가요?
- 오브젝트의 경우:
  - `for-in` 반복 - `for (var property in obj) { console.log(property); }`. 
    - 그러나, 이는 상속된 속성도 반복되며, 사용하기 전에 `obj.hasOwnProperty(property)` 체크를 추가해야 합니다.
  - `Object.keys()` - `Object.keys(obj).forEach(function (property) { ... })`. 
    - `Object.keys()`는 전달하는 객체의 열거 가능한 모든 속성을 나열하는 정적 메서드입니다.
  - `Object.getOwnPropertyNames()` - `Object.getOwnPropertyNames(obj).forEach(function (property) { ... })`.
    - `Object.getOwnPropertyNames()`는 전달하는 객체의 열거 가능한 속성과 열거불가능한 모든 속성을 나열하는 정적 메서드입니다.
- 배열의 경우:
  - `for`, `forEach`, `for-of`

#### curry 함수의 예를 들어 줄 수 있나요? 그리고 이 문법은 어떤 이점을 가지고 있나요?
- currying은 둘 이상의 매개 변수가 있는 함수가 여러 함수로 분리된 패턴으로, 직렬로 호출하면, 필요한 모든 매개 변수가 한 번에 하나씩 누적됩니다. 
- 이 기법은 함수형 스타일로 작성된 코드를 읽고, 합성하기 더 쉬워진 경우 유용할 수 있습니다. 
- 함수를 currying하려면, 하나의 함수로 시작하여, 하나의 매개 변수를 취하는 일련의 함수로 분리해야 합니다.

#### 파일 간에 코드를 공유하려면 어떻게 해야 합니까?
- 이것은 Javascript 환경에 따라 다릅니다.
- 클라이언트(브라우저 환경)에서는, 변수/함수가 전역 스코프(window)에 선언되어있는 한 모든 스크립트가 이를 참조할 수 있습니다. 또는, 보다 모듈형 접근 방식을 위해 RequireJS를 통해 비동기 모듈 정의(AMD)를 이용합니다.
- ES2015에서는 AMD 및 commonJS를 모두 대체하기 위한 모듈 문법을 정의합니다. 이 기능은 브라우저 및 노드 환경 모두에서 지원됩니다.

#### 정적 클래스 멤버를 만드는 이유는 무엇인가요?
- 정적 클래스 멤버(속성/메서드)는 클래스의 특정 인스턴스와 묶이지 않으며, 어떤 인스턴스가 이를 참조하는지에 관계없이 동일한 값을 가집니다. 
- 정적 속성은 일반적으로 설정(configuration) 변수이며 정적 메서드는 일반적으로 인스턴스의 상태에 의존하지 않는 순수 유틸리티 함수입니다.

#### Eslint가 무엇인가요? 
- Eslint는 소스코드를 스캔하여 문법적오류나 잠재적 오류까지 찾아내고 오류의 이유를 볼 수 있게 해주는 도구

#### npm과 yarn은 어떤게 다른가?
- 과거 깃허브에서 받은 소스코드를 npm i로 패키지를 설치 했을 때 이전과 버전정보가 다른 환경문제가 생길 수 있었는데 이것을 처리하기 위해서 yarn.lock 파일에서 처리할 수 있었다. 하지만, 현재는 npm의 package-lock.json에서 이 처리를 동일하게 사용할 수 있다.

#### 적응형과 반응형의 차이를 아는가?
- 반응형 웹은 하나의 템플릿을 사용해 모든 기기에 대응하는데 반해, 적응형 웹은 선별된 기기 유형에 따라 별도의 독립적인 템플릿이 요구

#### 가상돔 (virtual DOM)
- Virtual DOM은 실제 DOM 변화를 최소화 시켜주는 역할을 합니다.
- DOM 노드는 작은 변화에도 매우 복잡한 과정들이 다시 실행되기 때문에 DOM 변화가 잦을 경우 성능이 저하됩니다.
- Virtual DOM은 뷰에 변화가 있다면, 그 변화가 실제 DOM에 적용되기 전에 Virtual DOM에 적용시키고 최종 결과만 실제 DOM에 전달합니다.

#### 웹 소켓을 지원하지 않는 브라우저에서는 어떻게 리얼 타임 통신을 할 것인가
- 일반 http 스펙을 이용해서 실시간 통신을 흉내 낼 수 있는 방식으로 통신을 하게 해준다.
  - Socket.io(nodejs 기반), SockJS

#### 모듈 & 모듈 포맷 & 모듈 로더 & 모듈 번들러
- 모듈
  - 구현 세부사항을 캡슐화하고 공개API를 노출하여 다른 코드에서 쉽게 로드하고 사용할 수 있는 재사용가능한 코드 조각
- 모듈 포맷
  - 모듈을 정의하기위해 사용하는 문법. AMD, CommonJS, UMD, System.register같은 여러 모듈포맷이 등장했으며, ES6부터는 내장된 모듈 포맷을 사용할 수 있다.
- 모듈 로더
  - 주요 모듈 포맷으로 작성된 모듈을 런타임때 로드하고 해석. 대표적으로 RequireJS와 SystemJS가 있음.
- 모듈 번들러
  - 빌드 타임(컴파일 시간)에 실행해서 한개의 js파일로 내보냅니다. 대표적으로 Browerify와 Webpack이 있음.
- 모듈 로더와 모듈 번들러는 결국에는 모듈화된 파일들의 의존성을 관리하고 어떻게 실행시킬지를 구현해주는 도구들이다.


#### babel에 대해 설명해주세요
- ES6 이후의 문법으로 작성한 자바스크립트를 변환할 수 있을 뿐만 아니라, 아직 논의 단계에 있는 문법도 사용할 수 있도록 구성할 수 있다.

#### webpack에 대해 설명해주세요
- 웹팩은 프로젝트의 구조를 분석하고 자바스크립트 모듈을 비롯한 관련 리소스들을 찾은 다음 이를 브라우저에서 이용할 수 있는 번들로 묶고 패킹하는 모듈 번들러(Module bundler)다.
- 지정한 메인 파일에서 시작해 자바스크립트의 require(webpack commonJS 모듈 지원)과 import(ES6)문을 참고해 프로젝트의 모든 의존성을 조사하고 로더를 이용해 처리한 후 번들로 묶은 자바스크립트 파일을 생성한다.
- 자바스크립트 병합뿐만 아니라 CSS와 Sass 처리, 이미지 변환도 해결할 수 있다.
- loader라고 부르는 방법을 이용해 파일 확장자에 따라 필요한 다른 동작을 선언할 수 있다.
- loader는 다른 빌드 도구의 '작업(task)'이라고 생각할 수 있다.


#### 실제 코딩하면서 클로져를 많이 사용하는가? 주로 어떤 패턴으로 사용하는가?
- 모듈화할때와 변수를 프라이빗하게 쓰고 싶을 때 사용한다.

#### AMD와 CommonJS는 무엇인가요?
- 두 가지 모두 ES2015가 등장하기 전까지 JavaScript에 기본적으로 존재하지 않는 모듈 시스템을 구현하는 방법입니다. 
- CommonJS는 동기식인 반면 AMD는 비동기식입니다. 
- CommonJS는 서버사이드 개발을 염두에 두고 설계되었으며, AMD는 모듈의 비동기 로딩을 지원하므로 브라우저용으로 더 많이 사용됩니다.


## 출처
- https://gitlab.com/siots-study/topics/-/wikis/home
- https://github.com/yangshun/front-end-interview-handbook/blob/master/contents/kr/javascript-questions.md