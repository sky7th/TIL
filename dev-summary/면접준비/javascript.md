#### 함수형 프로그래밍이란
- 함수를 이용해서 사이드 이펙트 없도록 선언형 프로그래밍을 이용하는 것이다.

#### 함수형 프로그래밍의 컨셉
- 변경 가능한 상태를 불변상태(Immutab)로 만들어 SideEffect를 없애자.
- 모든 것은 객체이다.
- 코드를 간결하게 하고 가독성을 높여 구현할 로직에 집중 시키자.
- 동시성 작업을 보다 쉽게 안전하게 구현 하자.

#### OOP와 함수형 프로그래밍의 차이
- 객체지향과 함수형의 차이는 상태를 관리하는 점이다. 
- 객체지향의 경우 객체 안에 상태를 저장한다.
- 함수형 프로그래밍은 이런 상태를 제어하기보다는 상태를 저장하지 않고 없애는데 주력한다. 함수라는 것 자체가 입력값이 들어가면 이에 따른 특정한 출력값이 나오는 것으로 상태를 저장하지 않는다.
> 객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다. - 마이클 페더스

#### 순수함수란
- 동일한 입력에는 항상 같은 값을 반환해야 한다.
함수의 실행은 프로그램의 실행에 영향을 미치지 않아야 한다. (Side effect 가 없어야 한다)
- 순수 함수를 호출하면 프로그램의 어떠한 변화도 없고, 입력 값에 대한 결과를 예상할수 있어서 테스트하기가 쉽다.


#### 브라우저의 렌더링 과정


#### Promise란?
- Promise란 향후에 언젠가 사용하게 될 값을 생산해내는 객체이다. 
- 여기서 값은 얻을 수 있거나(resolved), 혹은 값을 얻지 못하는 대신에 그렇게 된 이유를 얻게 된다(rejected).


#### 클로저가 무엇이고 왜 쓰는지 설명하고 간단하게 코드로 구현해보아라.
- 중첩된 함수 구조에서 바깥 함수의 변수를 가져다 쓰는 내부 함수와, 그 변수가 저장되는 저장소를 포괄하여 클로저라고 부릅니다. 
- 클로저를 사용하는 이유는, private한 변수를 사용하고 싶을 때, 그리고 그 보호하고 싶은 변수에 접근 권한을 제어하고 싶을 때 사용합니다.

#### 불변성이 무엇인지와 가변성을 해결하기 위한 방법을 제시하라.
- 불변성이란, 원래의 값을 변경할 방법이 없는 성질을 말하며, 원시 타입들의 모든 값은 불변성을 가지고 있습니다. 이렇게 불변성을 가지는 값을 불변인 값이라고합니다. 이런 불변인 값을 바꾸기 위해서는 다른 값을 다시 대입하는 방법밖에 없습니다.
- 이 불변성과 대비되는 성질을 가변성이라하는데, 참조 타입인 객체가 이에 해당합니다. 객체는 가변이기 때문에 어디서 어떻게 변경될지 모른다는 불안함이 존재하는데, 이를 해결하기위해 Object.freeze를 쓸 수도 있지만 immutable.js 혹은 immer.js 같은 라이브러리를 더 많이 씁니다. 이런 라이브러리를 쓰면 객체의 내용을 변경하면 아예 새로운 객체를 반환해주는 방식으로 동작하여 원본 객체를 마치 불변인 값인양 다룰 수 있게됩니다.

#### 화살표 함수와 일반함수와의 차이점은?
- 일반 함수가 생성자로 사용될 수 있는 것과 달리 화살표 함수는 prototype 속성을 갖고 있지 않으며 생성자로 사용될 수 없습니다.
- 화살표함수는 스스로의 this, arguments, super를 가지지 않습니다.
- 일반 함수는 어떻게 호출되느냐에 따라 this를 결정하지만, 화살표함수는 어떻게 선언되느냐에 따라 this가 지정됩니다. 때문에 화살표는 this를 바꿀 수 없고, bind&call&apply 메소드를 사용할 수 없습니다.

#### 자바스크립트에서 this는 무엇인지?
- this는 생성자 혹은 메소드에서 어떠한 객체를 가리킬 때 사용하는 키워드입니다. this가 가리키는 객체는 상황에 따라 달라지는데,
  - 전역 공간에서 this - window 객체
  - 함수 내부에서 this - window 객체
  - 메소드 호출 시 - 메소드 호출 주체
  - 콜백에서 this - window - 하지만 this를 명시하거나 this를 바인딩해서 넘기면 그에 따른다.
  - 생성자 함수에서 this - 인스턴스

  위 상황으로 나뉠 수 있습니다.

#### == 와 === 차이
- ==연산자는 동등 연산자로, 피연산자가 서로 다른 타입이면 타입을 강제로 변환하여 비교합니다. 
- ===연산자는 일치 연산자로, 형 변환을 하지 않고 비교하기 때문에 두 피연산자를 더 정확하게 비교합니다. 
- 엄격한 비교를 위해 ===만을 쓰는 것이 권장되지만, null, undefined 체크시에는 ==를 써도 무방합니다.

#### 호이스팅이란?
- 호이스팅이란 var 변수 선언부나 함수 선언식이 선언과 동시에 해당 스코프의 최상단으로 끌어올려지는 현상을 가리킵니다.

#### function foo() {}와 var foo = function() {} 사이에서 foo 사용법의 차이에 대해 설명하시오.
- 전자는 함수 선언식으로 foo()라는 함수는 호이스팅되며, 후자는 함수 표현식으로 foo라는 변수의 선언부는 호이스팅 되지만 대입된 함수는 호이스팅되지 않습니다.

#### let, var 또는 const를 사용하여 생성된 변수들의 차이점은 무엇인가요?
- var : 함수스코프 / 재대입, 재선언, 호이스팅 모두 됨
- let : 블록스코프 / 재대입 가능, 재선언, 호이스팅 안 됨
- const : 블록스코프 / 재대입, 재선언, 호이스팅 안 됨

#### Function.prototype.bind에 대해 설명하시오.
- bind 메소드는 function 키워드로 선언된 함수 내부의 this를 내가 원하는 객체로 지정할 수 있게하는 메소드 입니다.

#### 엄격모드가 무엇이고 어떻게 사용하는 것이지?
- 엄격 모드란, 프로그래머가 실수하기 쉬운 몇 가지 문법에 대해 제약사항을 추가해주는 자바스크립트의 기능입니다. 
- 예를 들어, 프로그래머의 실수로 this가 전역 객체를 가리키게 될 시 이를 막고 this는 undefined를 반환하게 해줍니다. 
- 엄격 모드를 쓰기 위해서는 파일 혹은 함수 제일 위에 `'use strict';`를 작성해주면 되지만, ES2015 모듈을 이용해 작성된 코드는 항상 엄격 모드로 동작하기 때문에, `use strict';`를 붙여주지 않아도 엄격 모드로 동작합니다.

#### 고차 함수의 정의는 무엇입니까?
- 고차 함수의 정의는 함수를 인수로 받는 함수, 혹은 함수를 반환하는 함수입니다.

#### 자바스크립트 원시타입은 몇 개이고 전부 말하라.
- 총 6개며, `null`, `undefined`, `number`, `string`, `boolean`, `symbol`입니다.

#### Iterable과 Iterator이 무엇인가?
- Iterable이란 순회 가능한 객체를 말하고, Iterator란 Iterable 객체의 요소를 탐색하기 위한 포인터이다. 
- Iterator 객체 내부에는 next 메소드가 존재하고, next메소드는 value 속성과 done 속성이 들어있는 객체를 반환한다.

#### Generator함수에 대해 설명하세요
- iterable 객체를 반환해주는 특별한 함수입니다. iterable하지 않은 값을 iterable한 객체로 생성하거나 새로운 iterable 객체를 생성하고 싶을 때 가장 쉽게 사용할 수 있는 방법이기도 합니다.
function* 키워드로 함수를 만들 수 있으며 yield를 통해 값을 넘겨줄 수 있습니다.

#### Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가?
- 클래스란 비슷한 객체를 원하는 만큼 만들어낼 수 있는 생성자 함수가 하는 기능을 좀 더 간결하고 깔끔한 문법으로 구현할 수 있게끔해주는 오브젝트입니다. 
- 애초에 javascript에서의 Class는 다른 언어에서의 클래스처럼 실제로 상속기능이 있는 것이 아닌 prototype을 이용해 상속 기능을 구현한 것이기 때문에, ES5 스펙으로도 클래스를 구현할 수 있습니다.

#### ES6 클래스와 ES5 함수 생성자의 차이점은 무엇입니까?
- 클래스는 함수로 호출될 수 없다.
- 클래스 선언은 `let`과 `const` 처럼 블록스코프에 선언되며, 호이스팅이 일어나지않는다.
- 클래스의 메소드 안에서 `super` 키워드를 사용할 수 있다.

#### 클래스 상속보다 객체 구성을 선호한다는 것은 무엇을 의미하는가?
- 클래스 상속을 이용한 코드 재사용보다 작은 단위의 함수를 객체로 모아 조합하는 방식이 좋다.

#### 동기와 비동기의 차이점을 설명하라
- 동기는 작업이 시작되면 해당 작업이 끝날 때까지 다른 작업을 유보하는 것이고
- 비동기는 작업이 시작되고 작업이 끝나지 않은 도중이라도 다른 작업을 시작할 수 있다는 차이점이 있다.

#### Promise란 무엇이며 코드가 어떻게 구성되어있는가
- 언젠간 끝나는 작업의 결과값을 담는 객체이다. 
- 프로미스 생성자는 콜백을 인수로 받는다. 
- 콜백의 첫번째 인수는 resolve고, 콜백안에서 resolve에 인수로 넘겨준 값이 이 프로미스 객체의 결과값이 된다. 
- 두번째 인수는 reject고 예외 상황에서의 콜백을 작성한다.

```js
const p = new Promise(resolve => {
  setImeout(() => {
    resolve(value); //resolve에 인수로 준 값이 promise 객체의 결과값이 된다.
  }, ms);
});
```

#### Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명하라
- 프로미스는 then 메소드를 사용하여 콜백을 작성해줄 수 있고, 작성되는 문법이 콜백과 달리 깔끔하여 비동기식 코드를 동기식 코드처럼 작성할 수 있다는 장점이 있다.
- 콜백은 함수의 인자로 들어가는 함수를 말하며, 비동기식 코드를 콜백으로 작성하게되면 콜백 지옥에 빠질 수 있다는 단점이 있다.

#### Async, Await가 무엇이며, 사용해본 경험이 있는가
- 함수 앞에 async를 붙이면 해당 함수는 비동기 함수가 된다. 
- 이 비동기 함수 내부에서 await를 사용할 수 있는데, await를 쓰면 뒤에 오는 Promise(를 반환하는 함수)가 결과값을 가질 때까지 함수를 잠시 멈추고, Promise 통에 값이 채워지면 함수를 다시 실행하여 값을 반환한다.

#### 이벤트 루프란 무엇입니까?
- 호출 스택에서 작업을 처리하고, 오래 걸리는 작업은 브라우저에게 위임하고 다음 호출 스택의 작업을 처리ing하며, 브라우저에 위임된 작업이 끝나 작업 큐에 들어온 뒤 호출 스택이 빌 때까지 기다렸다 호출 스택에 들어가 처리되는 이 단일 스레드 루프를 이벤트 루프라고 한다.

#### function Person(){}, var person = Person(), var person = new Person() 의 차이점은 무엇입니까?
- 첫번째는 Person이라는 함수를 단순히 정의한 함수 선언식이고, 
- 두번째는 person이라는 변수에 Person함수 값을 대입한 것이고, 
- 마지막은 Person() constructor가 person이란 이름의 인스턴스을 생성한 것 입니다

#### 호스트 객체와 내장 객체의 차이점은 무엇입니까?
- 내장 객체는 이미 지정되어 있는 Array, String, Object 등등과 같은 객체입니다.
- 호스트 객체는 window, XMLHTTPRequest 등과 같이 런타임 환경 (브라우저 또는 노드)에 의해 제공됩니다.

#### 프로토타입 상속이 어떻게 작동하는지 설명하세요.
- 프로토타입 상속은 실제 상속을 받았다기 보다는 연결되어있는 프로토타입에 존재하는 속성을 공유할 수 있기 때문에 이것을 상속이라고 표현하는 것인데, 해당 객체에 불러온 속성이 없으면 연결된 프로토타입 객체로 가서 해당 속성을 찾아보고, 또 속성이 없으면 그 프로토타입 객체에 연결된 프로토타입 객체로 가서 속성을 찾아보는 방식이며, 이를 프로토타입 체인이라고 합니다.

#### DOM에 대해서 설명하세요.
- html파일로 만들어진 웹 문서를 브라우저에 렌더링 하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 변환하여 메모리에 보내줘야하는데, 
이 구조로 변환하는 단계를 parsing이라고 하고, 파싱 단계를 거쳐 변환된 모습인 '브라우저가 이해할 수 있는 구조 모델'을 DOM이라고 한다.

#### 이벤트 위임에 대해 설명하세요.
- 부모 요소에 event 리스너를 붙여주면, 자식 요소가 이벤트 버블링 단계에서 부모 요소에 있는 이벤트를 발생시킬 수 있는 것을 이용해 자식요소에 똑같은 이벤트를 하나하나 붙여주는 것 대신 부모 요소에 이벤트를 하나 붙여서 마치 모든 자식요소가 해당 이벤트 리스너를 가진 것 처럼 동작시킬 수 있는 것을 이벤트 위임이라고 합니다.
- 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간이 줄어듭니다.

#### event bubbling과 event capturing에 대해 설명하세요.
- 버블링 - 이벤트가 발생한 target에서 시작하여 상위 요소로 이벤트 flow가 옮겨가는 것
- 캡쳐링 - 이벤트가 발생한 target의 상위요소에서 시작하여 target의 지점으로 이벤트 flow가 내려오는 것

#### preventDefault와 stopPropagation의 차이점에 대해 설명하세요.
- preventDefault() : 어떠한 태그의 기본 이벤트 동작을 취소한다.
- stopPropagation() : 이벤트 전파(버블링, 캡쳐링)를 중단한다.

#### mouseover, mouseout 과 mouseenter, mouseleave의 차이점
- mouseover & mouseout - 이벤트 버블링이 적용되는 이벤트이기 때문에, 자식 요소에서도 이벤트가 실행된다.
- mouseenter & mouseleave - 이벤트 버블링이 적용되지 않으며, 오로지 이벤트가 발생한 target에서만 이벤트가 실행됩니다.

#### Ajax란 무엇인가 ?
- XHR 객체를 이용하여 서버와 상호작용하게 되면 서버와 통신 할 때마다 전체 페이지를 새로 고치지 않고 페이지의 일부만을 위한 데이터를 로드할 수 있다.
- Ajax는 이 XHR객체를 이용하여 JavaScript에서 클라이언트와 서버간에 비동기 통신 형태로 XML 데이터를 주고 받는 기술 그 자체라고 할 수 있다.

#### Ajax를 사용하면 문제가 있다. 그 문제는 무엇인가?
- 히스토리관리가 되지 않는다.
- 연속으로 데이터를 요청하면 서버 부하가 증가한다.
- XHR을 통해 통신하는중 진행정보가 보이지 않습니다.
- 바이너리 데이터를 보내거나 받을수 없다.
- 같은 서버에 있는 주소로만 ajax요청을 할 수 있다.

#### 자바스크립트 엔진이 무엇인가?
- 자바스크립트 엔진은 자바스크립트 코드를 읽고 컴파일하는 가상머신이다. 대표적으로는 크롬의 V8 엔진이 있다.

#### V8 의 특징
- V8 엔진은 C++ 로 작성 되었으며, ECMA-262 에 기재된 ECMAScript 및 WebAssembly 를 처리할 수 있다.
- JavaScript 소스 코드를 컴파일 하고, 실행한다.
- 생성하는 Object 를 메모리에 할당한다.
- 가비지 콜렉션을 이용해 더 이상 사용되지 않는 Object 의 메모리를 해제한다.
- Hidden Class 를 이용해 빠르게 프로퍼티에 접근한다.
- TurboFan 을 이용해 최적화된 코드로 만들어 속도 및 메모리를 최적화한다.

#### 스크립트의 속성 중에서 async 와 defer의 공통점과 차이점은?
- 둘 다 HTML을 파싱하면서 동시에 스크립트를 가져온다. 예전과 다르게 HTML파싱 작업은 일시정지 되지않는다.
- async는 HTML파싱 중에라도 스크립트가 준비되면 될 때마다 즉시 실행한다. 실행 순서가 다운로드 완료 시점에 의해 결정되므로 유의해야한다.
- defer는 HTML파싱 중에 스크립트 다운로드가 완료되더라도 바로 실행되지 않고, HTML파싱(구문분석)이 완료되면 스크립트가 실행된다. async와는 다르게 호출된 순서대로 실행된다.

#### Javascript 모듈 패턴(Javascript module pattern)"이 무엇인지 설명을 해주시고, 언제 사용하는지도 말씀해주시기 바랍니다.
- 디자인 패턴이라고 부르는 패턴 중 하나이며 모듈을 정의하는 방법 중 하나입니다.
- 네임스페이스 이용하여 함수 이름이나 변수가 출동을 예방할수 있습니다.
- 주로, private한 변수나 메소드를 구현하고 싶을 때 사용합니다.


## 출처
- https://gitlab.com/siots-study/topics/-/wikis/home