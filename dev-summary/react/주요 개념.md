## React 주의해야 할 점
#### props는 읽기 전용이다.
- 함수 컴포넌트나 클래스 컴포넌트 모두 컴포넌트의 자체 props를 수정해서는 안 된다.

#### 모든 React 컴포넌트는 자신의 props를 다룰 때 반드시 순수 함수처럼 동작해야 한다.

#### 클래스를 사용하면
- render 메서드는 업데이트가 발생할 때마다 호출되지만, 같은 DOM 노드로 `<Clock />`을 렌더링하는 경우 Clock 클래스의 단일 인스턴스만 사용된다. 
- 이것은 로컬 state와 생명주기 메서드와 같은 부가적인 기능을 사용할 수 있게 해준다.

## 생명주기 메서드
- componentDidMount()
  -  컴포넌트 출력물이 DOM에 렌더링 된 후에 실행된다.
- componentWillUnmount()

## React 렌더링 과정
1. ReactDOM.render()로 전달
2. 컴포넌트의 constructor를 호출
3. this.state를 초기화
4. React는 컴포넌트의 render() 메서드를 호출
5. 그 다음 React는 컴포넌트의 렌더링 출력값을 일치시키기 위해 DOM을 업데이트합니다.
6. 컴포넌트의 출력값이 DOM에 삽입되면, React는 componentDidMount() 생명주기 메서드를 호출합니다.
7. setState()를 호출하면 React는 state가 변경된 것을 인지하고 화면에 표시될 내용을 알아내기 위해 render() 메서드를 다시 호출
8. 이 때 render() 메서드 안의 this.state의 상태가 달라지게 되고 React는 이에 따라 DOM을 업데이트합니다.
9. 컴포넌트가 DOM으로부터 한 번이라도 삭제된 적이 있다면 React는 타이머를 멈추기 위해 componentWillUnmount() 생명주기 메서드를 호출한다.

## State를 올바르게 사용하기
#### 직접 State를 수정하지 말자.
- this.state를 지정할 수 있는 유일한 공간은 constructor이다.
#### State 업데이트는 비동기적일 수도 있다.
- this.props와 this.state가 비동기적으로 업데이트될 수 있기 때문에 다음 state를 계산할 때 해당 값에 의존해서는 안 된다.
- 수정하기 위해 객체보다는 함수를 인자로 사용하는 다른 형태의 setState()를 사용하자.
#### State 업데이트는 병합된다.


## 데이터는 아래로 흐른다.
- 부모 컴포넌트나 자식 컴포넌트 모두 특정 컴포넌트가 유상태인지 또는 무상태인지 알 수 없고, 그들이 함수나 클래스로 정의되었는지에 대해서 관심을 가질 필요가 없다.

## 이벤트 처리하기
React에서는 false를 반환해도 기본 동작을 방지할 수 없다. 반드시 preventDefault를 명시적으로 호출해야 한다.


## 조건부 렌더링
#### 컴포넌트가 렌더링하는 것을 막기
- 다른 컴포넌트에 의해 렌더링될 때 컴포넌트 자체를 숨기고 싶을 때는 렌더링 결과를 출력하는 대신 null을 반환하면 된다.


## 리스트와 Key
### Key
- Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕는다. 
- key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 한다.
- 만약 리스트 항목에 명시적으로 key를 지정하지 않으면 React는 기본적으로 인덱스를 key로 사용한다.

#### Key를 어떻게 사용하면 좋을까
- map() 함수 내부에 있는 엘리먼트에 key를 넣어 주는 게 좋다.
- Key는 형제 사이에서만 고유한 값이어야 한다.
- React에서 key는 힌트를 제공하지만 컴포넌트로 전달하지는 않는다. 컴포넌트에서 key와 동일한 값이 필요하면 다른 이름의 prop으로 명시적으로 전달한다.
- JSX에 map() 포함시키기
  - map() 함수가 너무 중첩된다면 컴포넌트로 추출 하는 것이 좋다.


## Form
전반적으로 `<input type="text">`, `<textarea>` 및 `<select>` 모두 매우 비슷하게 동작한다. 모두 제어 컴포넌트를 구현하는데 value 어트리뷰트를 허용한다.

### select
- select 태그에 multiple 옵션을 허용한다면 value 어트리뷰트에 배열을 전달할 수 있다.

#### 다중 입력 제어하기
- 여러 input 엘리먼트를 제어해야할 때, 각 엘리먼트에 name 어트리뷰트를 추가하고 event.target.name 값을 통해 핸들러가 어떤 작업을 할 지 선택할 수 있게 해준다.
- 주어진 input 태그의 name에 일치하는 state를 업데이트하기 위해 ES6의 computed property name 구문을 사용하자.
제어되는 Input Null 값
- value를 설정했는데 여전히 수정할 수 있다면 실수로 value를 undefined나 null로 설정했을 수 있다.
제어 컴포넌트의 대안
- 입력 폼을 구현하기 위한 대체 기술인 비제어 컴포넌트
- 유효성 검사, 방문한 필드 추적 및 폼 제출 처리와 같은 완벽한 해결을 원한다면 Formik이 대중적인 선택 중 하나이다.


## State 끌어올리기
React 애플리케이션 안에서 변경이 일어나는 데이터에 대해서는 “진리의 원천(source of truth)“을 하나만 두어야 한다.
state를 끌어올리는 작업은 양방향 바인딩 접근 방식보다 더 많은 “보일러 플레이트” 코드를 유발하지만, 버그를 찾고 격리하기 더 쉽게 만든다는 장점이 있다.
어떤 값이 props 또는 state로부터 계산될 수 있다면, 아마도 그 값을 state에 두어서는 안 된다.
UI에서 무언가 잘못된 부분이 있을 경우, React Developer Tools를 이용하여 props를 검사해보자.


## 합성 (Composition) vs 상속 (Inheritance)
React는 강력한 합성 모델을 가지고 있으며, 상속 대신 합성을 사용하여 컴포넌트 간에 코드를 재사용하는 것이 좋다.

#### 컴포넌트에서 다른 컴포넌트를 담기
- 특수한 children prop을 사용하여 자식 엘리먼트를 출력에 그대로 전달할 수 있다.
- 컴포넌트를 props로 전달하여 전달받은 컴포넌트에서 출력하고 싶은 위치에 출력할 수 있다.

#### 특수화
- 더 “구체적인” 컴포넌트가 “일반적인” 컴포넌트를 렌더링하고 props를 통해 내용을 구성한다.
- WelcomeDialog는 Dialog의 구체적인 경우이다.

#### 굳이 상속을 사용하지 않아도 된다.
- props와 합성은 명시적이고 안전한 방법으로 컴포넌트의 모양과 동작을 커스터마이징하는데 필요한 모든 유연성을 제공한다.
- 컴포넌트는 원시 타입의 값, React 엘리먼트 혹은 함수 등 어떠한 props도 받을 수 있다.
- UI가 아닌 기능을 여러 컴포넌트에서 재사용하기를 원한다면, 별도의 JavaScript 모듈로 분리하는 것이 좋다.

## React로 사고하기
React의 가장 멋진 점 중 하나는 앱을 설계하는 방식이다.

#### 1. UI를 컴포넌트 계층 구조로 나누기
   - 우리가 할 첫 번째 일은 모든 컴포넌트(와 하위 컴포넌트)의 주변에 박스를 그리고 그 각각에 이름을 붙이는 것이다.
   - 디자이너의 Photoshop 레이어 이름이 React 컴포넌트의 이름이 될 수 있다.
   - 항상 단일 책임 원칙을 생각하자.
   - 각 컴포넌트가 데이터 모델의 한 조각을 나타내도록 분리하자.

#### 2. React로 정적인 버전 만들기
   - 정적 버전을 만들기 위해 state를 사용하지 말아라. state는 오직 상호작용을 위해, 즉 시간이 지남에 따라 데이터가 바뀌는 것에 사용한다.
   - 간단한 예시에서는 보통 하향식으로 만드는 게 쉽지만 프로젝트가 커지면 상향식으로 만들고 테스트를 작성하면서 개발하기가 더 쉽다.

#### 3. UI state에 대한 최소한의 (하지만 완전한) 표현 찾아내기
   - 애플리케이션에서 필요로 하는 변경 가능한 state의 최소 집합을 생각해보자.
   - 여기서 핵심은 중복배제원칙이다.
   - 어떤 게 state가 되어야 하는지는 각 데이터에 대해 아래의 세 가지 질문을 통해 결정할 수 있다.
     1. 부모로부터 props를 통해 전달됩니까? 그러면 확실히 state가 아닙니다.
     2. 시간이 지나도 변하지 않나요? 그러면 확실히 state가 아닙니다.
     3. 컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가요? 그렇다면 state가 아닙니다.

#### 4. State가 어디에 있어야 할 지 찾기
  - 아래는 어떤 컴포넌트가 어떤 state를 가져야 하는 지 결정하는 방법이다.
   - 애플리케이션이 가지는 각각의 state에 대해서:
     - state를 기반으로 렌더링하는 모든 컴포넌트를 찾아라.
     - 공통 소유 컴포넌트 (common owner component)를 찾아라. (계층 구조 내에서 특정 state가 있어야 하는 모든 컴포넌트들의 상위에 있는 하나의 컴포넌트).
     - 공통 혹은 더 상위에 있는 컴포넌트가 state를 가져야 한다.
     - state를 소유할 적절한 컴포넌트를 찾지 못하였다면, state를 소유하는 컴포넌트를 하나 만들어서 공통 오너 컴포넌트의 상위 계층에 추가하자.

#### 5. 역방향 데이터 흐름 추가하기
   - React는 전통적인 양방향 데이터 바인딩(two-way data binding)과 비교하면 더 많은 타이핑을 필요로 하지만 데이터 흐름을 명시적으로 보이게 만들어서 프로그램이 어떻게 동작하는지 파악할 수 있게 도와준다.
   - 컴포넌트는 그 자신의 state만 변경할 수 있기 때문에 상위 컴포넌트는 하위 컴포넌트에 콜백을 넘겨서 state가 업데이트되어야 할 때마다 호출되도록 한다.