## 정규화  
데이터가 꼬이는 것을 막기 위해 테이블을 잘게 나누는 것

### 제1정규형(1NF) - 원자성
- 모든 속성은 반드시 하나의 값만 가져야 한다.

### 제2정규형(2NF) - 부분 종속
- 모든 속성은 반드시 모든 기본키에 종속되어야 한다.
  - 기본키 일부에만 종속되어서는 안된다.
- 예) "주문"과 관계없이 "음료" 데이터 입력, 수정, 삭제가 가능해야 한다.

### 제3정규형(3NF) - 이행 종속
- 기본키가 아닌 모든 속성간에는 서로 종속될 수 없다.


## 반정규화  
반정규화는 성능 향상을 위해 정규화를 포기하는 것이다. 그러나 데이터 무결성이 보장 되지 않으므로 제한적으로 사용해야 한다. 

### 테이블 반정규화
- 테이블 병합
  - 비즈니스 로직 상 `JOIN` 되는 경우가 많아 통합하는 것이 성능 측면에서 유리할 경우 고려
  1. 1:1 관계 테이블 병합
  2. 1:M 관계 테이블 병합
  3. 슈퍼 서브 타입 테이블 병합

- 테이블 분할
  1. 수직 분할: 컬럼 단위로 테이블을 1:1 분리
  2. 수평 분할: row 단위로 테이블 분리

- 테이블 추가
  1. 중복 테이블 추가
     - 타 업무 또는 타 서버에 있는 테이블과 동일한 구조의 테이블 추가, 원격 `JOIN` 방지
  2. 통계 테이블 추가 
     - 통계값을 미리 계산해서 저장하는 테이블 추가
     - 예) 일일주문수량, 일일주문금액 컬럼이 존재하는 주문통계 테이블
  3. 이력 테이블 추가
     - 마스터 테이블에 존재하는 row를 트랜잭션 발생 시점에 따라 복사해두는 테이블 추가
  4. 부분 테이블 추가
     - 자주 조회되는 컬럼들만 별도로 모아놓은 테이블 추가

### 컬럼 반정규화
- 중복 컬럼 추가
  - `JOIN` 프로세스를 줄이기 위해 중복 컬럼 추가
  - `SELECT` 비용은 감소하나, `UPDATE` 비용은 증가
  - 예) 배송 테이블에 회원번호 컬럼 추가
- 파생 컬럼 추가
  - 계산을 통해 얻어지는 결과값을 테이블에 컬럼으로 저장
  - 예) 주문 테이블에 주문총금액 컬럼 추가
- 이력 테이블 컬럼 추가
  - 이력 테이블에 기능성 컬럼 추가 (최신 여부, 시작일/종료일 등)
  - 예) 상품가격 변경이력 테이블에 최신여부 컬럼 추가

### 관계 반정규화
- 중복관계 추가
  - 데이터 처리를 위해 여러 경로를 거쳐야 할 겨우 관계를 중복시킴으로써 성능 개선
  - 예) 배송 테이블에 회원번호 컬럼 추가


## TOP-N 쿼리
어떤 특정 컬럼으로 sorting 한 다음에 1등부터 N등까지를 뽑아내는 쿼리

### 음원 사이트에서 스트리밍 수로 TOP 10을 뽑을 때
1. 10개의 음원 스트리밍 수를 읽어서 sorting하고 길이가 10인 배열에 담는다.
1. 11번째 부터는 10번째와 비교해서 11번째가 스트리밍 수가 더 적으면 11번째를 버린다.
1. 반복...하다가 10번째보다 스트리밍 수가 더 많은 음원이 등장한다.
1. 10번째 음원을 버리고 등장한 음원이 어느 위치에 삽입이 되어야 하는지 정렬을 한 다음에 순위를 조정한다.

### 장점
- 전체 데이터를 가지고 sorting을 하는 것보다 훨씬 부하가 덜 하다.
- Sort Area가 PGA 영역에 위치하고 있기 때문에 이럴 경우에는 PGA 영역에서만 수행이 되고 완료될 확률이 높다.
  - Sort Area를 넘어서서 디스크 영역까지 사용을 하는 경우가 생길 수 있기 때문에 성능에 부하가 생길 가능성이 많다.


#### ROWNUM
- row가 출력된 순서대로 매겨지는 일종의 시퀀스같은 컬럼

#### ROWID
- 해당 row가 가지는 고유한 주소값

```sql
-- oracle
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY FROM (
    SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY
    FROM EMPLOYEES
    ORDER BY SALARY DESC
)
WHERE ROWNUM <= 10
```
- COUNT STOPKEY 오퍼레이션 실행 여부 확인
  - 실행해야만 TOP-N 알고리즘이 작동을 한다.

```sql
-- mysql
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY FROM (
    SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY
    @EMPLOYEE_RANK := IF(@CURRENT_SALARY = SALARY, 
                            @EMPLOYEE_RANK + 1, 
                            1
                        ) AS EMPLOYEE_RANK,
    @CURRENT_SALARY := SALARY
    FROM EMPLOYEES
    ORDER BY SALARY DESC
)
WHERE EMPLOYEE_RANK <= 10
```

## JOIN 수행 원리
같은 `JOIN` 쿼리라고 해도 내부적으로 모두 같은 방식으로 풀리는 것이 아니다.

어떤 쿼리에 어떤 방식이 어울리는지를 알고 있으면 튜닝하는데 도움이 된다.
### `JOIN`의 종류
`INNER JOIN`, `OUTER JOIN`, `CROSS JOIN`, `NATURAL JOIN`

### `JOIN`의 수행 원리
`NESTED LOOP JOIN`, `SORT MERGE JOIN`, `HASH JOIN`


### `NESTED LOOP JOIN`
- 중첩 for문과 같은 원리이다.
  - Outer Table은 바깥 for문, Inner Table은 안쪽 for문에 해당한다.
- 보통은 OLTP성 환경의 쿼리에 적절하다.
- 1:M의 관계에서 1에 해당하는 소량의 데이터를 가진 테이블이 Outer Table로 설정되는 것이 성능에 유리하다.
- 주의
  - `INNER TABLE`에서 `JOIN` 컬럼에 인덱스가 걸려있지 않으면 한건 한건 갈 때마다 전부 full scan을 해야 한다.
  - 대량의 테이블을 `JOIN`하는 방식으로는 적절하지 않다.

### `SORT MERGE JOIN`
- 우선 두 테이블을 `JOIN` 컬럼을 기준으로 sorting을 시키고 `JOIN`을 시키는 방식이다.
  - 중첩 for문과 유사한 방식이지만 약간 다른 점이 존재한다.
- `INNER TABLE` 쪽에 적절한 인덱스가 없어서 `NESTED LOOP JOIN`을 쓰기에 너무 비효율일때 쓰일 수 있다.
- Equal `JOIN`이 아니라 범위로 `JOIN`을 하는 경우에 쓰일 수 있다.
- Table Random Access가 일어나지 않고 sorting 작업이 PGA 영역에서 수행되기 때문에 경합이 발생하지 않아서 성능에 유리한 이점이 있다.

### `HASH JOIN`
- 배치에서 쓰면 좋은 수행 원리이다.
- 대용량 테이블을 `JOIN` 할 때 이용하면 좋다.
- 1:M의 관계에서 M쪽이 굉장한 대용량 테이블일 경우 1쪽 테이블을 Build Input으로 삼아서 Hash 영역에 저장을 해놓는다.
  - Hash 영역에 올라갈 때는 `JOIN` 컬럼을 기준으로 Hash Function이 적용되기 때문에 이 Key 컬럼에 중복값이 없을수록 성능에 유리하다.
- Hash 영역은 Sort Area처럼 PGA 영역에 있기 때문에 처리 속도가 매우 빠르다.
- `SORT MERGE JOIN` 처럼 Random Access 부하가 없다.
- 주의
  - Equal `JOIN`만 가능하다.
  - Hash 영역에 들어가는 테이블의 크기가 충분히 작아야지 성능에 유리하다.
    - Hash 영역의 크기가 정해져 있는데 이 테이블의 용량이 그걸 초과해서 벗어나게 되면 디스크 영역을 사용하게 되기 때문에 성능에 불리해진다.
  - 수행 빈도가 높은 OLTP 환경에서 Hash `JOIN`으로 풀리게 되면 오히려 CPU나 메모리 사용량이 늘어서 성능이 안좋아질 수가 있다.
  - `HASH JOIN`으로 풀리면 안되는데 `HASH JOIN`으로 풀리고 있다면 힌트를 써서 다른 수행 방식으로 풀릴 수 있도록 유도를 하는 것이 효과적인 튜닝 방법이다.

## 인덱스
### 어떤 컬럼을 인덱스로 설정해야 효율적일까 ?
특정조건부터 스캔을 한다. 
1. 조건(where)절에 자주 등장하는 컬럼을 인덱스로 설정하면 효율적 
2. order by 절에 자주 등장하는 컬럼을 인덱스로 지정, 인덱스는 소팅이되어 저장되어있기 때문에 인덱스에서 바로 꺼내서 사용할 수 있음 
3. 여러 컬럼을 조합해서 만들기도 함 

### 인덱스의 단점
- 인덱스는 오브젝트이다. 
- `SELECT`는 빨라질지 몰라도 `INSERT`나 `UPDATE`는 느려진다. 
- 정렬이 된 상태로 저장되어야 하기 때문에 어느자리에 `INSERT`할지 찾아서 저장해야 한다. 
- 또한 테이블만 하는것이 아니라 인덱스도 똑같이 해줘야하기 때문에 비용이 많이 든다.


### 결합 인덱스
- 결합하는 컬럼들의 순서가 중요하다.
- `WHERE`절에서 equal 조건으로 많이 쓰이는 컬럼, 분별력이 높은 컬럼들이 앞으로 오는게 효율적이다.
- 예) 성별보다는 아이디처럼 분별력이 높은 것이 앞으로 와야 한다.

### 인덱스가 무용지물이 되는 경우
1. 인덱스 컬럼을 가공
   - Bad: `WHERE SUBSTR(ORDER_NO, 1, 4) = '2019'`
   - Good: `WHERE ORDER_NO LIKE '2019%'` 
2. 인덱스 컬럼의 묵시적 형변환 (같은 타입으로 비교해야 한다)
   - Bad: `WHERE REG_DATE = '20190730`
   - Good: `WHERE REG_DATE = TO_DATE('20190730', 'YYYYMMDD')` 
3. 인덱스 부정형 비교
   - Bad: `WHERE MEM_TYPE != '10'` 
   - Good: `WHERE MEM_TYPE IN ('20', '30')` 
4. `LIKE` 연산자 사용 시 %가 앞에 위치
5. `OR` 조건 사용은 `UNION ALL`로 대체하자.

### 인덱스 스캔방식 
- index range scan : 어떤 시작점 부터 특정 범위를 스캔하는 방식 
- index full scan, index skip scan , index fast full scan 등등이 있다.


### 인덱스를 탄다고 무조건 빨라지지는 않음, 손익분기점이 있다. 
- 테이블이 가지고 있는 전체 데이터 양의 10% ~ 15% 일때 효율적이고 그 이상일 때는 풀스캔이 더 빠르다. 


## 쿼리 실행 순서

1. 처음에는 `FROM`절로 가서 여기 적혀있는 테이블이 존재하는 테이블인지 확인하고 'SELECT' 권한이 있는지 체크한다.
1. `FROM`절을 체크를 해서 어떤 테이블을 엑세스 해야되는지를 확인을 한다.
1. `WHERE`절에서 어떤 조건들이 있는지 확인을 하고 조건에 맞는 row들을 가져온다.
1. `GROUP BY`을 수행해서 그루핑한다.
1. `HAVING`절에서 `GROUP BY` 한 것 중에서 버려야할 데이터들이 있는지 체크한다.
1. `SELECT`절에서 출력할 컬럼들을 체크한다.
   - *이랑 컬럼 선택해서 가져온거랑 사실상 드는 비용은 같다.(인덱스를 생각하지 않을 때)
1. `ORDER BY`절에서 정렬을 한다.
   - `SELECT`절에서 alias를 지정해 놨을 경우에 `ORDER BY`절에서는 사용이 가능하다.