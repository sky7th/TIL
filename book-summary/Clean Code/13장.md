## 13장. 동시성

동시성과 깔끔한 코드는 양립하기 아주 어렵다.

이 장에서 논할 것들
- 여러 스레드를 동시에 돌리는 이유
- 여러 스레드를 동시에 돌리는 어려움
- 이런 어려움에 대처하고 깨끗한 코드를 작성하는 방법
- 동시성을 테스트하는 방법과 문제점

### 동시성이 필요한 이유
동시성을 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다.

많은 사용자를 동시에 처리하면 시스템 응답 시간을 높일 수 있다.

#### 미신과 오해
다음은 동시성과 관련한 일반적인 미신과 오해다.
- 동시성은 항상 성능을 높여준다.
  - 동시성은 때로 성능을 높여준다.
  - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
  - 어느 쪽도 일상적으로 발생하는 상황은 아니다.
- 동시성을 구현해도 설계는 변하지 않는다.
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
  - 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  - 실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야만 한다.

반대로 다음은 동시성과 관련된 타당한 생각 몇 가지다.
- 동시성은 다소 부하를 유발한다.
  - 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다.
- 동시성은 복잡하다.
  - 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
  - 그래서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.
- 동시성을 구현하려면 흔히 근본적인 설계전략을 재고해야 한다.

### 난관
```java
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```
인스턴스 X를 생성하고, lastIdUsed 필드를 42로 설정한 다음, 두 스레드가 해당 인스턴스를 공유한다. 

이제 두 스레드가 getNextId();를 호출한다고 가정하자. 

결과는 셋 중 하나다.
- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed는 44가 된다.
- 한 스레드는 44을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 44가 된다.
- 한 스레드는 43을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 43가 된다.

두 스레드가 같은 변수를 동시에 참조하면 얼마 안 되는 몇몇 조합이 세 번째와 같이 잘못된 결과를 내놓는다.

### 동시성 방어 원칙
지금부터 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술을 소개한다.

#### 단일 책임 원칙 (SRP)
- 동시성 코드는 다른 코드와 분리하라.
#### 따름 정리: 자료 범위를 제한하라
- 자료를 캡슐화하라. 공유 자료를 최대한 줄여라.
#### 따름 정리: 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
#### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

### 라이브러리를 이해하라
언어가 제공하는 클래스를 검토하라. 

자바에서는 java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks를 익혀라.

### 실행 모델을 이해하라
다중 스레드 애플리케이션을 분류하는 방식은 여러 가지다.

#### 생성자-소비자 (Producer-Consumer)
아래서 대기열은 Producer/Consumer 스레드가 함께 사용하는 한정된 자원이다.

- 하나 이상의 Producer 스레드가 정보를 버퍼나 대기열에 넣는다.
  - Producer 스레드는 대기열에 빈 공간이 있을 때만 정보를 채운다.(아니면 기다림)
  - 정보를 채우고 Consumer 스레드에게 시그널을 보낸다.
- 하나 이상의 Consumer 스레드가 대기열에서 정보를 가져와 사용한다.
  - 있을 때만 가져감. 채워질 때까지 기다림
  - 대기열에 빈 공간이 있을 경우 Producer 스레드에 시그널을 보낸다.

잘못하면 Producer/Consumer 스레드가 둘 다 진행 가능한 상태임에도 서로에게서 시그널을 기다릴 위험이 있다.

#### 읽기-쓰기 (Readers-Writers)
읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 쓰레드가 이 공유 자원을 이따금 갱신하는 상황을 의미한다.

- 읽는 스레드의 작업 동안 쓰는 스레드의 작업이 기다리면 정보 업데이트가 되지 않는 문제가 있다
- 쓰는 스레드의 작업 동안 읽는 스레드의 작업이 기다리면 이것도 기아 현상의 위험이 있음.

보통은 쓰기 스레드가 읽기 스레드가 끝날 때까지 기다린다.

#### 식사하는 철학자들
[식사하는 철학자들 - 위키 백과](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
자바에서는 synchronized를 개별 메서드를 보호할 수 있도록 지원한다.

공유 객체 하나를 여러 synchronized 메서드로 보호하고 있다면 불필요한 의존성이 생길 수 있으므로 꼭 필요한지 확인하고 가급적이면 하나로 줄이도록 한다.

### 동기화하는 부분을 작게 만들어라
synchronized를 사용하면 락을 설정한다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다.
- synchronized를 남발하는 코드는 바람직하지 않다.

하지만 임계영역은 반드시 보호해야 한다. 때문에 이 임계영역 수를 최대한 줄여야 한다.
- 그렇다고 해서 하나의 거대한 임계 영역으로 통합해서는 안된다. 통합된 임계 영역에는 이 영역을 사용하려고 하는 스레드도 늘어나고 그건 곧 경쟁으로 이어지고 성능이 떨어지기 때문이다.

### 올바른 종료 코드는 구현하기 어렵다
깔끔하게 종료하는 코드는 올바로 구현하기 어렵다.
- 데드락이 가장 흔히 발생하는 문제이다.(스레드가 오지 않을 시그널을 기다린다)
> 예를 들어 부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다 자원을 해제하고 종료하는 시스템이 있었다고 가정하자. 만약 자식 스레드 중 하나가 데드락에 걸린다면 부모 스레드는 영원히 기다릴 것이다.

### 스레드 코드 테스트하기
동시성 코드 테스트는 통과 되는 경우도 있고 아닌 경우가 있기 마련이다. 이와 관련된 테스트를 진행할 때 어떤 것을 고려해야 할까?

#### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
일회성 문제라고 치부하지 말자! 무시하고 개발을 진행하면 나중에는 더 큰 문제가 발생한다

#### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
즉, 스레드가 호출하는 POJO를 만들자
스레드 환경에서 생기는 버그 / 스레드 환경 밖에서 생기는 버그 동시에 디버깅을 하지말자

#### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 쓰레드 코드를 구현하라
다양한 설정+목적(ex : 스레드 수 변경)으로 테스트 할 수 있게 코드를 구현하라
테스트 코드를 빨리, 천천히, 다양한 속도로 돌려보자
반복 테스트가 가능하도록 테스트케이스를 작성하자

#### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요하다.
- 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.

#### 프로세서 수보다 많은 스레드를 돌려보자
- 시스템이 스레드를 swapping(스와핑) 할 때도 문제가 발생  한다.
- 이 때, 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다

#### 다른 플랫폼에서 돌려보라
- 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

#### 코드에 보조 코드(instrument)를 넣어 돌려라. 강제로 실패를 일으키게 해보라